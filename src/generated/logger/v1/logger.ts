// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.32.0
// source: logger/v1/logger.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "logger.v1";

/** Ack is a response to a request */
export interface Ack {
  /** status is the status of the request */
  status: string;
  /** message is the message of the request */
  message: string;
}

/** CreateRunRequest is a request to create a new run */
export interface CreateRunRequest {
  /** run_id is the ID of the run */
  runId: string;
  /** name is the name of the run */
  name: string;
  /** project is the project of the run */
  project: string;
  /** tags are the tags of the run */
  tags: string[];
  /** config_json is the config of the run */
  configJson: string;
  /** created_at is the timestamp of the run */
  createdAt?: Date | undefined;
  /** description is the description of the run */
  description?: string | undefined;
  /** notes are the notes of the run */
  notes?: string | undefined;
  /** entity is the entity of the run */
  entity?: string | undefined;
}

/** Record is a record in the logger */
export interface Record {
  /** timestamp is the timestamp of the record */
  timestamp?: Date | undefined;
  /** payload_json is the payload of the record */
  payloadJson: string;
  /** payload_name is the name of the payload (used in artifact storage) */
  payloadName?: string | undefined;
  /** sequence is the sequence of the record (used as "step" in history) */
  sequence?: number | undefined;
  /** runtime is the runtime of the record (seconds since ran began) */
  runtime?: number | undefined;
}

/** StoreRecordBatchRequest is a request to store a batch of records */
export interface StoreRecordBatchRequest {
  /** run_id is the ID of the run */
  runId: string;
  /** project is the project of the record */
  project: string;
  /** type is the record type */
  type: string;
  /** records are the records to store */
  records: Record[];
}

function createBaseAck(): Ack {
  return { status: "", message: "" };
}

export const Ack: MessageFns<Ack> = {
  encode(
    message: Ack,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ack {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ack {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Ack): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<Ack>): Ack {
    return Ack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Ack>): Ack {
    const message = createBaseAck();
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCreateRunRequest(): CreateRunRequest {
  return {
    runId: "",
    name: "",
    project: "",
    tags: [],
    configJson: "",
    createdAt: undefined,
    description: undefined,
    notes: undefined,
    entity: undefined,
  };
}

export const CreateRunRequest: MessageFns<CreateRunRequest> = {
  encode(
    message: CreateRunRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.configJson !== "") {
      writer.uint32(42).string(message.configJson);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.createdAt),
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.description !== undefined) {
      writer.uint32(58).string(message.description);
    }
    if (message.notes !== undefined) {
      writer.uint32(66).string(message.notes);
    }
    if (message.entity !== undefined) {
      writer.uint32(74).string(message.entity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRunRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.configJson = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.entity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRunRequest {
    return {
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      configJson: isSet(object.configJson)
        ? globalThis.String(object.configJson)
        : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : undefined,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
      entity: isSet(object.entity)
        ? globalThis.String(object.entity)
        : undefined,
    };
  },

  toJSON(message: CreateRunRequest): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.configJson !== "") {
      obj.configJson = message.configJson;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    if (message.entity !== undefined) {
      obj.entity = message.entity;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRunRequest>): CreateRunRequest {
    return CreateRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRunRequest>): CreateRunRequest {
    const message = createBaseCreateRunRequest();
    message.runId = object.runId ?? "";
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.tags = object.tags?.map(e => e) || [];
    message.configJson = object.configJson ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.description = object.description ?? undefined;
    message.notes = object.notes ?? undefined;
    message.entity = object.entity ?? undefined;
    return message;
  },
};

function createBaseRecord(): Record {
  return {
    timestamp: undefined,
    payloadJson: "",
    payloadName: undefined,
    sequence: undefined,
    runtime: undefined,
  };
}

export const Record: MessageFns<Record> = {
  encode(
    message: Record,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(
        toTimestamp(message.timestamp),
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.payloadJson !== "") {
      writer.uint32(18).string(message.payloadJson);
    }
    if (message.payloadName !== undefined) {
      writer.uint32(26).string(message.payloadName);
    }
    if (message.sequence !== undefined) {
      writer.uint32(32).int64(message.sequence);
    }
    if (message.runtime !== undefined) {
      writer.uint32(45).float(message.runtime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Record {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payloadJson = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payloadName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sequence = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.runtime = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Record {
    return {
      timestamp: isSet(object.timestamp)
        ? fromJsonTimestamp(object.timestamp)
        : undefined,
      payloadJson: isSet(object.payloadJson)
        ? globalThis.String(object.payloadJson)
        : "",
      payloadName: isSet(object.payloadName)
        ? globalThis.String(object.payloadName)
        : undefined,
      sequence: isSet(object.sequence)
        ? globalThis.Number(object.sequence)
        : undefined,
      runtime: isSet(object.runtime)
        ? globalThis.Number(object.runtime)
        : undefined,
    };
  },

  toJSON(message: Record): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.payloadJson !== "") {
      obj.payloadJson = message.payloadJson;
    }
    if (message.payloadName !== undefined) {
      obj.payloadName = message.payloadName;
    }
    if (message.sequence !== undefined) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.runtime !== undefined) {
      obj.runtime = message.runtime;
    }
    return obj;
  },

  create(base?: DeepPartial<Record>): Record {
    return Record.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Record>): Record {
    const message = createBaseRecord();
    message.timestamp = object.timestamp ?? undefined;
    message.payloadJson = object.payloadJson ?? "";
    message.payloadName = object.payloadName ?? undefined;
    message.sequence = object.sequence ?? undefined;
    message.runtime = object.runtime ?? undefined;
    return message;
  },
};

function createBaseStoreRecordBatchRequest(): StoreRecordBatchRequest {
  return { runId: "", project: "", type: "", records: [] };
}

export const StoreRecordBatchRequest: MessageFns<StoreRecordBatchRequest> = {
  encode(
    message: StoreRecordBatchRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    for (const v of message.records) {
      Record.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StoreRecordBatchRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreRecordBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.records.push(Record.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreRecordBatchRequest {
    return {
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      records: globalThis.Array.isArray(object?.records)
        ? object.records.map((e: any) => Record.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StoreRecordBatchRequest): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.records?.length) {
      obj.records = message.records.map(e => Record.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StoreRecordBatchRequest>): StoreRecordBatchRequest {
    return StoreRecordBatchRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StoreRecordBatchRequest>,
  ): StoreRecordBatchRequest {
    const message = createBaseStoreRecordBatchRequest();
    message.runId = object.runId ?? "";
    message.project = object.project ?? "";
    message.type = object.type ?? "";
    message.records = object.records?.map(e => Record.fromPartial(e)) || [];
    return message;
  },
};

export type LoggerServiceService = typeof LoggerServiceService;
export const LoggerServiceService = {
  /** CreateRun creates a new run */
  createRun: {
    path: "/logger.v1.LoggerService/CreateRun",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRunRequest) =>
      Buffer.from(CreateRunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateRunRequest.decode(value),
    responseSerialize: (value: Ack) => Buffer.from(Ack.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Ack.decode(value),
  },
  /** StoreRecordBatch stores a batch of records */
  storeRecordBatch: {
    path: "/logger.v1.LoggerService/StoreRecordBatch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreRecordBatchRequest) =>
      Buffer.from(StoreRecordBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      StoreRecordBatchRequest.decode(value),
    responseSerialize: (value: Ack) => Buffer.from(Ack.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Ack.decode(value),
  },
} as const;

export interface LoggerServiceServer extends UntypedServiceImplementation {
  /** CreateRun creates a new run */
  createRun: handleUnaryCall<CreateRunRequest, Ack>;
  /** StoreRecordBatch stores a batch of records */
  storeRecordBatch: handleUnaryCall<StoreRecordBatchRequest, Ack>;
}

export interface LoggerServiceClient extends Client {
  /** CreateRun creates a new run */
  createRun(
    request: CreateRunRequest,
    callback: (error: ServiceError | null, response: Ack) => void,
  ): ClientUnaryCall;
  createRun(
    request: CreateRunRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Ack) => void,
  ): ClientUnaryCall;
  createRun(
    request: CreateRunRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Ack) => void,
  ): ClientUnaryCall;
  /** StoreRecordBatch stores a batch of records */
  storeRecordBatch(
    request: StoreRecordBatchRequest,
    callback: (error: ServiceError | null, response: Ack) => void,
  ): ClientUnaryCall;
  storeRecordBatch(
    request: StoreRecordBatchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Ack) => void,
  ): ClientUnaryCall;
  storeRecordBatch(
    request: StoreRecordBatchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Ack) => void,
  ): ClientUnaryCall;
}

export const LoggerServiceClient = makeGenericClientConstructor(
  LoggerServiceService,
  "logger.v1.LoggerService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): LoggerServiceClient;
  service: typeof LoggerServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
