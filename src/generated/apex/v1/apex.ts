// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.20.3
// source: apex/v1/apex.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "apex.v1";

/**
 * A request to generate completions following Apex CompletionsRequest format.
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface ChatCompletionRequest {
  /** uids: the miner UIDs that will be used to generate the completion (optional). */
  uids: number[];
  /** messages: the messages to generate completions for. */
  messages: ChatMessage[];
  /** seed: the seed to use for the completion. */
  seed?: number | undefined;
  /** task: the task to generate completions for (e.g. "InferenceTask"). */
  task?: string | undefined;
  /** model: the LLM name to use for the completion. (optional, suggest leaving this empty as not all LLMs are supported) */
  model?: string | undefined;
  /** test_time_inference: whether to use test time inference. */
  testTimeInference?: boolean | undefined;
  /** mixture: whether to use a mixture of miners to create a slower but better answer. */
  mixture?: boolean | undefined;
  /** sampling_parameters: the sampling parameters to use for the completion. */
  samplingParameters?: SamplingParameters | undefined;
  /** inference_mode: the inference mode to use for the completion. */
  inferenceMode?: string | undefined;
  /** json_format: whether to use JSON format for the completion. */
  jsonFormat?: boolean | undefined;
  /** stream: whether to stream the completion. */
  stream?: boolean | undefined;
  /** timeout: the timeout for the completion in seconds. */
  timeout?: number | undefined;
}

/**
 * The sampling parameters for the completion.
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface SamplingParameters {
  /** temperature: the temperature to use for the completion. */
  temperature: number;
  /** top_p: the top_p to use for the completion. */
  topP: number;
  /** top_k: the top_k to use for the completion. */
  topK?: number | undefined;
  /** max_new_tokens: the max_new_tokens to use for the completion. */
  maxNewTokens: number;
  /** do_sample: whether to do sample for the completion. */
  doSample: boolean;
}

/**
 * A chat completion response, following OpenAI's ChatCompletion format.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion.py
 */
export interface ChatCompletionResponse {
  /** id: the id of the completion. */
  id: string;
  /** choices: the choices of the completion. */
  choices: Choice[];
  /** created: the created time of the completion. */
  created: number;
  /** model: the model of the completion. */
  model: string;
  /** object: the object of the completion. */
  object: string;
  /** service_tier: the service tier of the completion. (not currently supported in Apex) */
  serviceTier: string;
  /** system_fingerprint: the system fingerprint of the completion. (not currently supported in Apex) */
  systemFingerprint: string;
  /** usage: the usage of the completion. (not currently supported in Apex) */
  usage?: CompletionUsage | undefined;
}

/**
 * The choice object containing the message response from the LLM for the completion.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion.py
 */
export interface Choice {
  /** finish_reason: the finish reason of the choice. */
  finishReason: string;
  /** index: the index of the choice. */
  index: number;
  /** logprobs: the logprobs of the choice. */
  logprobs?: ChoiceLogprobs | undefined;
  /** message: the message of the choice. */
  message?: ChatCompletionMessage | undefined;
}

/**
 * The message response object from the LLM.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message.py
 */
export interface ChatCompletionMessage {
  /** content: the content of the message. */
  content: string;
  /** refusal: the refusal of the message. (not currently supported in Apex) */
  refusal: string;
  /** role: the role of the message. */
  role: string;
  /** annotations: the annotations of the message. (not currently supported in Apex) */
  annotations: Annotation[];
  /** audio: the audio of the message. (not currently supported in Apex) */
  audio?: ChatCompletionAudio | undefined;
  /** function_call: the function call of the message. */
  functionCall?: FunctionCall | undefined;
  /** tool_calls: the tool calls of the message. */
  toolCalls: ChatCompletionMessageToolCall[];
}

/**
 * The annotation object for the message. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message.py
 */
export interface Annotation {
  /** content: the content of the annotation. */
  content: string;
  /** role: the role of the annotation. */
  role: string;
}

/**
 * The audio object for the message. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_audio.py
 */
export interface ChatCompletionAudio {
  /** id: the id of the audio. */
  id: string;
  /** data: the data of the audio. */
  data: string;
  /** expires_at: the expires at of the audio. */
  expiresAt: number;
  /** transcript: the transcript of the audio. */
  transcript: string;
}

/**
 * The function call object for the message.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message.py
 */
export interface FunctionCall {
  /** arguments: the arguments of the function call. */
  arguments: string[];
  /** name: the name of the function call. */
  name: string;
}

/**
 * The tool call object for the message.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message_tool_call.py
 */
export interface ChatCompletionMessageToolCall {
  /** id: the id of the tool call. */
  id: string;
  /** function: the function object for the tool call. */
  function?: FunctionMessage | undefined;
  /** type: the type of the tool call. */
  type: string;
}

/**
 * The function object for the tool call.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message_tool_call.py
 */
export interface FunctionMessage {
  /** arguments: the arguments of the function. */
  arguments: string[];
  /** name: the name of the function. */
  name: string;
}

/**
 * A streaming chunk response, following OpenAI's ChatCompletionChunk format.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChatCompletionChunkResponse {
  /** id: the id of the chunk. */
  id: string;
  /** choices: the choices of the chunk. */
  choices: ChunkChoice[];
  /** created: the created time of the chunk. */
  created: number;
  /** model: the model of the chunk. */
  model: string;
  /** object: the object of the chunk. (not currently supported in Apex) */
  object: string;
  /** service_tier: the service tier of the chunk. (not currently supported in Apex) */
  serviceTier: string;
  /** system_fingerprint: the system fingerprint of the chunk. (not currently supported in Apex) */
  systemFingerprint: string;
  /** usage: the usage of the chunk. (not currently supported in Apex) */
  usage?: CompletionUsage | undefined;
}

/**
 * The choice object for the chunk.
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface ChatMessage {
  /** role: the role of the message. */
  role: string;
  /** content: the content of the message. */
  content: string;
}

/**
 * The choice object for the chunk.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChunkChoice {
  /** delta: the delta of the choice. */
  delta?: ChoiceDelta | undefined;
  /** finish_reason: the finish reason of the choice. */
  finishReason: string;
  /** index: the index of the choice. */
  index: number;
  /** logprobs: the logprobs of the choice. (not currently supported in Apex) */
  logprobs?: ChoiceLogprobs | undefined;
}

/**
 * The logprobs object for the choice.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceLogprobs {
  /** content: the content of the logprobs. */
  content: ChatCompletionTokenLogprob[];
  /** refusal: the refusal of the logprobs. */
  refusal: ChatCompletionTokenLogprob[];
}

/**
 * The delta object for the choice.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDelta {
  /** content: the content of the delta. */
  content: string;
  /** function_call: the function call of the delta. */
  functionCall?: ChoiceDeltaFunctionCall | undefined;
  /** refusal: the refusal of the delta. */
  refusal: string;
  /** role: the role of the delta. */
  role: string;
  /** tool_calls: the tool calls of the delta. */
  toolCalls: ChoiceDeltaToolCall[];
}

/**
 * The function call object for the delta.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDeltaFunctionCall {
  /** arguments: the arguments of the function call. */
  arguments: string[];
  /** name: the name of the function call. */
  name: string;
}

/**
 * The tool call object for the delta.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDeltaToolCall {
  /** index: the index of the tool call. */
  index: number;
  /** id: the id of the tool call. */
  id: string;
  /** function: the function object for the tool call. */
  function?: ChoiceDeltaToolCallFunction | undefined;
  /** type: the type of the tool call. */
  type: string;
}

/**
 * The function object for the tool call.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDeltaToolCallFunction {
  /** arguments: the arguments of the function. */
  arguments: string[];
  /** name: the name of the function. */
  name: string;
}

/**
 * The chat completion token logprob object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_token_logprob.py
 */
export interface ChatCompletionTokenLogprob {
  /** token: the token of the logprob. */
  token: string;
  /** bytes: the bytes of the logprob. */
  bytes: number[];
  /** logprob: the logprob of the token. */
  logprob: number;
  /** top_logprobs: the top logprobs of the token. */
  topLogprobs: TopLogprob[];
}

/**
 * The top logprob object for the token. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_token_logprob.py
 */
export interface TopLogprob {
  /** token: the token of the logprob. */
  token: string;
  /** bytes: the bytes of the logprob. */
  bytes: number[];
  /** logprob: the logprob of the token. */
  logprob: number;
}

/**
 * The completion usage object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/completion_usage.py
 */
export interface CompletionUsage {
  /** completion_tokens: the completion tokens of the usage. */
  completionTokens: number;
  /** prompt_tokens: the prompt tokens of the usage. */
  promptTokens: number;
  /** total_tokens: the total tokens of the usage. */
  totalTokens: number;
  /** completion_tokens_details: the completion tokens details of the usage. */
  completionTokensDetails?: CompletionTokensDetails | undefined;
  /** prompt_tokens_details: the prompt tokens details of the usage. */
  promptTokensDetails?: PromptTokensDetails | undefined;
}

/**
 * The completion tokens details object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/completion_usage.py
 */
export interface CompletionTokensDetails {
  /** accepted_prediction_tokens: the accepted prediction tokens of the details. */
  acceptedPredictionTokens: number;
  /** audio_tokens: the audio tokens of the details. */
  audioTokens: number;
  /** reasoning_tokens: the reasoning tokens of the details. */
  reasoningTokens: number;
  /** rejected_prediction_tokens: the rejected prediction tokens of the details. */
  rejectedPredictionTokens: number;
}

/**
 * The prompt tokens details object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/completion_usage.py
 */
export interface PromptTokensDetails {
  /** audio_tokens: the audio tokens of the details. */
  audioTokens: number;
  /** cached_tokens: the cached tokens of the details. */
  cachedTokens: number;
}

/**
 * A web retrival request from Apex
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface WebRetrievalRequest {
  /** uids: the miner UIDs that will be used to generate the completion (optional). */
  uids: number[];
  /** search_query: the search query. */
  searchQuery: string;
  /** n_miners: the number of miners to use for the query. */
  nMiners?: number | undefined;
  /** n_results: the number of results to return. */
  nResults?: number | undefined;
  /** max_response_time: the max response time to allow for the miners to respond in seconds. */
  maxResponseTime?: number | undefined;
  /** timeout: the timeout for the web retrieval in seconds. */
  timeout?: number | undefined;
}

/**
 * A web search result from Apex
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface WebSearchResult {
  /** url: the url of the result. */
  url: string;
  /** content: the entire page contents. */
  content: string;
  /** relevant: the relevant part of the page best fitting the query.. */
  relevant: string;
}

/**
 * A web retrieval response from Apex
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface WebRetrievalResponse {
  /** results: the results of the web retrieval. */
  results: WebSearchResult[];
}

function createBaseChatCompletionRequest(): ChatCompletionRequest {
  return {
    uids: [],
    messages: [],
    seed: undefined,
    task: undefined,
    model: undefined,
    testTimeInference: undefined,
    mixture: undefined,
    samplingParameters: undefined,
    inferenceMode: undefined,
    jsonFormat: undefined,
    stream: undefined,
    timeout: undefined,
  };
}

export const ChatCompletionRequest: MessageFns<ChatCompletionRequest> = {
  encode(
    message: ChatCompletionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.uids) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.seed !== undefined) {
      writer.uint32(24).int64(message.seed);
    }
    if (message.task !== undefined) {
      writer.uint32(34).string(message.task);
    }
    if (message.model !== undefined) {
      writer.uint32(42).string(message.model);
    }
    if (message.testTimeInference !== undefined) {
      writer.uint32(48).bool(message.testTimeInference);
    }
    if (message.mixture !== undefined) {
      writer.uint32(56).bool(message.mixture);
    }
    if (message.samplingParameters !== undefined) {
      SamplingParameters.encode(
        message.samplingParameters,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.inferenceMode !== undefined) {
      writer.uint32(74).string(message.inferenceMode);
    }
    if (message.jsonFormat !== undefined) {
      writer.uint32(80).bool(message.jsonFormat);
    }
    if (message.stream !== undefined) {
      writer.uint32(88).bool(message.stream);
    }
    if (message.timeout !== undefined) {
      writer.uint32(96).int64(message.timeout);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.uids.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uids.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.seed = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.task = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.testTimeInference = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mixture = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.samplingParameters = SamplingParameters.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.inferenceMode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.jsonFormat = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.stream = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.timeout = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionRequest {
    return {
      uids: globalThis.Array.isArray(object?.uids)
        ? object.uids.map((e: any) => globalThis.Number(e))
        : [],
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
      seed: isSet(object.seed) ? globalThis.Number(object.seed) : undefined,
      task: isSet(object.task) ? globalThis.String(object.task) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      testTimeInference: isSet(object.testTimeInference)
        ? globalThis.Boolean(object.testTimeInference)
        : undefined,
      mixture: isSet(object.mixture)
        ? globalThis.Boolean(object.mixture)
        : undefined,
      samplingParameters: isSet(object.samplingParameters)
        ? SamplingParameters.fromJSON(object.samplingParameters)
        : undefined,
      inferenceMode: isSet(object.inferenceMode)
        ? globalThis.String(object.inferenceMode)
        : undefined,
      jsonFormat: isSet(object.jsonFormat)
        ? globalThis.Boolean(object.jsonFormat)
        : undefined,
      stream: isSet(object.stream)
        ? globalThis.Boolean(object.stream)
        : undefined,
      timeout: isSet(object.timeout)
        ? globalThis.Number(object.timeout)
        : undefined,
    };
  },

  toJSON(message: ChatCompletionRequest): unknown {
    const obj: any = {};
    if (message.uids?.length) {
      obj.uids = message.uids.map(e => Math.round(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map(e => ChatMessage.toJSON(e));
    }
    if (message.seed !== undefined) {
      obj.seed = Math.round(message.seed);
    }
    if (message.task !== undefined) {
      obj.task = message.task;
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.testTimeInference !== undefined) {
      obj.testTimeInference = message.testTimeInference;
    }
    if (message.mixture !== undefined) {
      obj.mixture = message.mixture;
    }
    if (message.samplingParameters !== undefined) {
      obj.samplingParameters = SamplingParameters.toJSON(
        message.samplingParameters,
      );
    }
    if (message.inferenceMode !== undefined) {
      obj.inferenceMode = message.inferenceMode;
    }
    if (message.jsonFormat !== undefined) {
      obj.jsonFormat = message.jsonFormat;
    }
    if (message.stream !== undefined) {
      obj.stream = message.stream;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Math.round(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionRequest>): ChatCompletionRequest {
    return ChatCompletionRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChatCompletionRequest>,
  ): ChatCompletionRequest {
    const message = createBaseChatCompletionRequest();
    message.uids = object.uids?.map(e => e) || [];
    message.messages =
      object.messages?.map(e => ChatMessage.fromPartial(e)) || [];
    message.seed = object.seed ?? undefined;
    message.task = object.task ?? undefined;
    message.model = object.model ?? undefined;
    message.testTimeInference = object.testTimeInference ?? undefined;
    message.mixture = object.mixture ?? undefined;
    message.samplingParameters =
      object.samplingParameters !== undefined &&
      object.samplingParameters !== null
        ? SamplingParameters.fromPartial(object.samplingParameters)
        : undefined;
    message.inferenceMode = object.inferenceMode ?? undefined;
    message.jsonFormat = object.jsonFormat ?? undefined;
    message.stream = object.stream ?? undefined;
    message.timeout = object.timeout ?? undefined;
    return message;
  },
};

function createBaseSamplingParameters(): SamplingParameters {
  return {
    temperature: 0,
    topP: 0,
    topK: undefined,
    maxNewTokens: 0,
    doSample: false,
  };
}

export const SamplingParameters: MessageFns<SamplingParameters> = {
  encode(
    message: SamplingParameters,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.temperature !== 0) {
      writer.uint32(9).double(message.temperature);
    }
    if (message.topP !== 0) {
      writer.uint32(17).double(message.topP);
    }
    if (message.topK !== undefined) {
      writer.uint32(25).double(message.topK);
    }
    if (message.maxNewTokens !== 0) {
      writer.uint32(32).int64(message.maxNewTokens);
    }
    if (message.doSample !== false) {
      writer.uint32(40).bool(message.doSample);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SamplingParameters {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamplingParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.temperature = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.topP = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.topK = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxNewTokens = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.doSample = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamplingParameters {
    return {
      temperature: isSet(object.temperature)
        ? globalThis.Number(object.temperature)
        : 0,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : 0,
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      maxNewTokens: isSet(object.maxNewTokens)
        ? globalThis.Number(object.maxNewTokens)
        : 0,
      doSample: isSet(object.doSample)
        ? globalThis.Boolean(object.doSample)
        : false,
    };
  },

  toJSON(message: SamplingParameters): unknown {
    const obj: any = {};
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== 0) {
      obj.topP = message.topP;
    }
    if (message.topK !== undefined) {
      obj.topK = message.topK;
    }
    if (message.maxNewTokens !== 0) {
      obj.maxNewTokens = Math.round(message.maxNewTokens);
    }
    if (message.doSample !== false) {
      obj.doSample = message.doSample;
    }
    return obj;
  },

  create(base?: DeepPartial<SamplingParameters>): SamplingParameters {
    return SamplingParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SamplingParameters>): SamplingParameters {
    const message = createBaseSamplingParameters();
    message.temperature = object.temperature ?? 0;
    message.topP = object.topP ?? 0;
    message.topK = object.topK ?? undefined;
    message.maxNewTokens = object.maxNewTokens ?? 0;
    message.doSample = object.doSample ?? false;
    return message;
  },
};

function createBaseChatCompletionResponse(): ChatCompletionResponse {
  return {
    id: "",
    choices: [],
    created: 0,
    model: "",
    object: "",
    serviceTier: "",
    systemFingerprint: "",
    usage: undefined,
  };
}

export const ChatCompletionResponse: MessageFns<ChatCompletionResponse> = {
  encode(
    message: ChatCompletionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.choices) {
      Choice.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.created !== 0) {
      writer.uint32(24).int64(message.created);
    }
    if (message.model !== "") {
      writer.uint32(34).string(message.model);
    }
    if (message.object !== "") {
      writer.uint32(42).string(message.object);
    }
    if (message.serviceTier !== "") {
      writer.uint32(50).string(message.serviceTier);
    }
    if (message.systemFingerprint !== "") {
      writer.uint32(58).string(message.systemFingerprint);
    }
    if (message.usage !== undefined) {
      CompletionUsage.encode(message.usage, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.choices.push(Choice.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.created = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.object = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.serviceTier = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.systemFingerprint = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.usage = CompletionUsage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => Choice.fromJSON(e))
        : [],
      created: isSet(object.created) ? globalThis.Number(object.created) : 0,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      serviceTier: isSet(object.serviceTier)
        ? globalThis.String(object.serviceTier)
        : "",
      systemFingerprint: isSet(object.systemFingerprint)
        ? globalThis.String(object.systemFingerprint)
        : "",
      usage: isSet(object.usage)
        ? CompletionUsage.fromJSON(object.usage)
        : undefined,
    };
  },

  toJSON(message: ChatCompletionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map(e => Choice.toJSON(e));
    }
    if (message.created !== 0) {
      obj.created = Math.round(message.created);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (message.serviceTier !== "") {
      obj.serviceTier = message.serviceTier;
    }
    if (message.systemFingerprint !== "") {
      obj.systemFingerprint = message.systemFingerprint;
    }
    if (message.usage !== undefined) {
      obj.usage = CompletionUsage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionResponse>): ChatCompletionResponse {
    return ChatCompletionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChatCompletionResponse>,
  ): ChatCompletionResponse {
    const message = createBaseChatCompletionResponse();
    message.id = object.id ?? "";
    message.choices = object.choices?.map(e => Choice.fromPartial(e)) || [];
    message.created = object.created ?? 0;
    message.model = object.model ?? "";
    message.object = object.object ?? "";
    message.serviceTier = object.serviceTier ?? "";
    message.systemFingerprint = object.systemFingerprint ?? "";
    message.usage =
      object.usage !== undefined && object.usage !== null
        ? CompletionUsage.fromPartial(object.usage)
        : undefined;
    return message;
  },
};

function createBaseChoice(): Choice {
  return {
    finishReason: "",
    index: 0,
    logprobs: undefined,
    message: undefined,
  };
}

export const Choice: MessageFns<Choice> = {
  encode(
    message: Choice,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.finishReason !== "") {
      writer.uint32(10).string(message.finishReason);
    }
    if (message.index !== 0) {
      writer.uint32(16).int64(message.index);
    }
    if (message.logprobs !== undefined) {
      ChoiceLogprobs.encode(message.logprobs, writer.uint32(26).fork()).join();
    }
    if (message.message !== undefined) {
      ChatCompletionMessage.encode(
        message.message,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Choice {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logprobs = ChoiceLogprobs.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = ChatCompletionMessage.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Choice {
    return {
      finishReason: isSet(object.finishReason)
        ? globalThis.String(object.finishReason)
        : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      logprobs: isSet(object.logprobs)
        ? ChoiceLogprobs.fromJSON(object.logprobs)
        : undefined,
      message: isSet(object.message)
        ? ChatCompletionMessage.fromJSON(object.message)
        : undefined,
    };
  },

  toJSON(message: Choice): unknown {
    const obj: any = {};
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.logprobs !== undefined) {
      obj.logprobs = ChoiceLogprobs.toJSON(message.logprobs);
    }
    if (message.message !== undefined) {
      obj.message = ChatCompletionMessage.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<Choice>): Choice {
    return Choice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Choice>): Choice {
    const message = createBaseChoice();
    message.finishReason = object.finishReason ?? "";
    message.index = object.index ?? 0;
    message.logprobs =
      object.logprobs !== undefined && object.logprobs !== null
        ? ChoiceLogprobs.fromPartial(object.logprobs)
        : undefined;
    message.message =
      object.message !== undefined && object.message !== null
        ? ChatCompletionMessage.fromPartial(object.message)
        : undefined;
    return message;
  },
};

function createBaseChatCompletionMessage(): ChatCompletionMessage {
  return {
    content: "",
    refusal: "",
    role: "",
    annotations: [],
    audio: undefined,
    functionCall: undefined,
    toolCalls: [],
  };
}

export const ChatCompletionMessage: MessageFns<ChatCompletionMessage> = {
  encode(
    message: ChatCompletionMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.refusal !== "") {
      writer.uint32(18).string(message.refusal);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.audio !== undefined) {
      ChatCompletionAudio.encode(
        message.audio,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.functionCall !== undefined) {
      FunctionCall.encode(
        message.functionCall,
        writer.uint32(50).fork(),
      ).join();
    }
    for (const v of message.toolCalls) {
      ChatCompletionMessageToolCall.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refusal = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.audio = ChatCompletionAudio.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.functionCall = FunctionCall.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toolCalls.push(
            ChatCompletionMessageToolCall.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionMessage {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      refusal: isSet(object.refusal) ? globalThis.String(object.refusal) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      audio: isSet(object.audio)
        ? ChatCompletionAudio.fromJSON(object.audio)
        : undefined,
      functionCall: isSet(object.functionCall)
        ? FunctionCall.fromJSON(object.functionCall)
        : undefined,
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) =>
            ChatCompletionMessageToolCall.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: ChatCompletionMessage): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.refusal !== "") {
      obj.refusal = message.refusal;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map(e => Annotation.toJSON(e));
    }
    if (message.audio !== undefined) {
      obj.audio = ChatCompletionAudio.toJSON(message.audio);
    }
    if (message.functionCall !== undefined) {
      obj.functionCall = FunctionCall.toJSON(message.functionCall);
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map(e =>
        ChatCompletionMessageToolCall.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionMessage>): ChatCompletionMessage {
    return ChatCompletionMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChatCompletionMessage>,
  ): ChatCompletionMessage {
    const message = createBaseChatCompletionMessage();
    message.content = object.content ?? "";
    message.refusal = object.refusal ?? "";
    message.role = object.role ?? "";
    message.annotations =
      object.annotations?.map(e => Annotation.fromPartial(e)) || [];
    message.audio =
      object.audio !== undefined && object.audio !== null
        ? ChatCompletionAudio.fromPartial(object.audio)
        : undefined;
    message.functionCall =
      object.functionCall !== undefined && object.functionCall !== null
        ? FunctionCall.fromPartial(object.functionCall)
        : undefined;
    message.toolCalls =
      object.toolCalls?.map(e =>
        ChatCompletionMessageToolCall.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { content: "", role: "" };
}

export const Annotation: MessageFns<Annotation> = {
  encode(
    message: Annotation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.content = object.content ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseChatCompletionAudio(): ChatCompletionAudio {
  return { id: "", data: "", expiresAt: 0, transcript: "" };
}

export const ChatCompletionAudio: MessageFns<ChatCompletionAudio> = {
  encode(
    message: ChatCompletionAudio,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(24).int64(message.expiresAt);
    }
    if (message.transcript !== "") {
      writer.uint32(34).string(message.transcript);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionAudio {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transcript = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionAudio {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      expiresAt: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : 0,
      transcript: isSet(object.transcript)
        ? globalThis.String(object.transcript)
        : "",
    };
  },

  toJSON(message: ChatCompletionAudio): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    if (message.transcript !== "") {
      obj.transcript = message.transcript;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionAudio>): ChatCompletionAudio {
    return ChatCompletionAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatCompletionAudio>): ChatCompletionAudio {
    const message = createBaseChatCompletionAudio();
    message.id = object.id ?? "";
    message.data = object.data ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    message.transcript = object.transcript ?? "";
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { arguments: [], name: "" };
}

export const FunctionCall: MessageFns<FunctionCall> = {
  encode(
    message: FunctionCall,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCall {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCall>): FunctionCall {
    return FunctionCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCall>): FunctionCall {
    const message = createBaseFunctionCall();
    message.arguments = object.arguments?.map(e => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChatCompletionMessageToolCall(): ChatCompletionMessageToolCall {
  return { id: "", function: undefined, type: "" };
}

export const ChatCompletionMessageToolCall: MessageFns<ChatCompletionMessageToolCall> =
  {
    encode(
      message: ChatCompletionMessageToolCall,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.id !== "") {
        writer.uint32(10).string(message.id);
      }
      if (message.function !== undefined) {
        FunctionMessage.encode(
          message.function,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.type !== "") {
        writer.uint32(26).string(message.type);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChatCompletionMessageToolCall {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChatCompletionMessageToolCall();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.id = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.function = FunctionMessage.decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.type = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChatCompletionMessageToolCall {
      return {
        id: isSet(object.id) ? globalThis.String(object.id) : "",
        function: isSet(object.function)
          ? FunctionMessage.fromJSON(object.function)
          : undefined,
        type: isSet(object.type) ? globalThis.String(object.type) : "",
      };
    },

    toJSON(message: ChatCompletionMessageToolCall): unknown {
      const obj: any = {};
      if (message.id !== "") {
        obj.id = message.id;
      }
      if (message.function !== undefined) {
        obj.function = FunctionMessage.toJSON(message.function);
      }
      if (message.type !== "") {
        obj.type = message.type;
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChatCompletionMessageToolCall>,
    ): ChatCompletionMessageToolCall {
      return ChatCompletionMessageToolCall.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChatCompletionMessageToolCall>,
    ): ChatCompletionMessageToolCall {
      const message = createBaseChatCompletionMessageToolCall();
      message.id = object.id ?? "";
      message.function =
        object.function !== undefined && object.function !== null
          ? FunctionMessage.fromPartial(object.function)
          : undefined;
      message.type = object.type ?? "";
      return message;
    },
  };

function createBaseFunctionMessage(): FunctionMessage {
  return { arguments: [], name: "" };
}

export const FunctionMessage: MessageFns<FunctionMessage> = {
  encode(
    message: FunctionMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionMessage {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionMessage): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionMessage>): FunctionMessage {
    return FunctionMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionMessage>): FunctionMessage {
    const message = createBaseFunctionMessage();
    message.arguments = object.arguments?.map(e => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChatCompletionChunkResponse(): ChatCompletionChunkResponse {
  return {
    id: "",
    choices: [],
    created: 0,
    model: "",
    object: "",
    serviceTier: "",
    systemFingerprint: "",
    usage: undefined,
  };
}

export const ChatCompletionChunkResponse: MessageFns<ChatCompletionChunkResponse> =
  {
    encode(
      message: ChatCompletionChunkResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.id !== "") {
        writer.uint32(10).string(message.id);
      }
      for (const v of message.choices) {
        ChunkChoice.encode(v!, writer.uint32(18).fork()).join();
      }
      if (message.created !== 0) {
        writer.uint32(24).int64(message.created);
      }
      if (message.model !== "") {
        writer.uint32(34).string(message.model);
      }
      if (message.object !== "") {
        writer.uint32(42).string(message.object);
      }
      if (message.serviceTier !== "") {
        writer.uint32(50).string(message.serviceTier);
      }
      if (message.systemFingerprint !== "") {
        writer.uint32(58).string(message.systemFingerprint);
      }
      if (message.usage !== undefined) {
        CompletionUsage.encode(message.usage, writer.uint32(66).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChatCompletionChunkResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChatCompletionChunkResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.id = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.choices.push(ChunkChoice.decode(reader, reader.uint32()));
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.created = longToNumber(reader.int64());
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.model = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.object = reader.string();
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.serviceTier = reader.string();
            continue;
          }
          case 7: {
            if (tag !== 58) {
              break;
            }

            message.systemFingerprint = reader.string();
            continue;
          }
          case 8: {
            if (tag !== 66) {
              break;
            }

            message.usage = CompletionUsage.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChatCompletionChunkResponse {
      return {
        id: isSet(object.id) ? globalThis.String(object.id) : "",
        choices: globalThis.Array.isArray(object?.choices)
          ? object.choices.map((e: any) => ChunkChoice.fromJSON(e))
          : [],
        created: isSet(object.created) ? globalThis.Number(object.created) : 0,
        model: isSet(object.model) ? globalThis.String(object.model) : "",
        object: isSet(object.object) ? globalThis.String(object.object) : "",
        serviceTier: isSet(object.serviceTier)
          ? globalThis.String(object.serviceTier)
          : "",
        systemFingerprint: isSet(object.systemFingerprint)
          ? globalThis.String(object.systemFingerprint)
          : "",
        usage: isSet(object.usage)
          ? CompletionUsage.fromJSON(object.usage)
          : undefined,
      };
    },

    toJSON(message: ChatCompletionChunkResponse): unknown {
      const obj: any = {};
      if (message.id !== "") {
        obj.id = message.id;
      }
      if (message.choices?.length) {
        obj.choices = message.choices.map(e => ChunkChoice.toJSON(e));
      }
      if (message.created !== 0) {
        obj.created = Math.round(message.created);
      }
      if (message.model !== "") {
        obj.model = message.model;
      }
      if (message.object !== "") {
        obj.object = message.object;
      }
      if (message.serviceTier !== "") {
        obj.serviceTier = message.serviceTier;
      }
      if (message.systemFingerprint !== "") {
        obj.systemFingerprint = message.systemFingerprint;
      }
      if (message.usage !== undefined) {
        obj.usage = CompletionUsage.toJSON(message.usage);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChatCompletionChunkResponse>,
    ): ChatCompletionChunkResponse {
      return ChatCompletionChunkResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChatCompletionChunkResponse>,
    ): ChatCompletionChunkResponse {
      const message = createBaseChatCompletionChunkResponse();
      message.id = object.id ?? "";
      message.choices =
        object.choices?.map(e => ChunkChoice.fromPartial(e)) || [];
      message.created = object.created ?? 0;
      message.model = object.model ?? "";
      message.object = object.object ?? "";
      message.serviceTier = object.serviceTier ?? "";
      message.systemFingerprint = object.systemFingerprint ?? "";
      message.usage =
        object.usage !== undefined && object.usage !== null
          ? CompletionUsage.fromPartial(object.usage)
          : undefined;
      return message;
    },
  };

function createBaseChatMessage(): ChatMessage {
  return { role: "", content: "" };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(
    message: ChatMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatMessage>): ChatMessage {
    return ChatMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatMessage>): ChatMessage {
    const message = createBaseChatMessage();
    message.role = object.role ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseChunkChoice(): ChunkChoice {
  return { delta: undefined, finishReason: "", index: 0, logprobs: undefined };
}

export const ChunkChoice: MessageFns<ChunkChoice> = {
  encode(
    message: ChunkChoice,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.delta !== undefined) {
      ChoiceDelta.encode(message.delta, writer.uint32(10).fork()).join();
    }
    if (message.finishReason !== "") {
      writer.uint32(18).string(message.finishReason);
    }
    if (message.index !== 0) {
      writer.uint32(24).int64(message.index);
    }
    if (message.logprobs !== undefined) {
      ChoiceLogprobs.encode(message.logprobs, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkChoice {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delta = ChoiceDelta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logprobs = ChoiceLogprobs.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkChoice {
    return {
      delta: isSet(object.delta)
        ? ChoiceDelta.fromJSON(object.delta)
        : undefined,
      finishReason: isSet(object.finishReason)
        ? globalThis.String(object.finishReason)
        : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      logprobs: isSet(object.logprobs)
        ? ChoiceLogprobs.fromJSON(object.logprobs)
        : undefined,
    };
  },

  toJSON(message: ChunkChoice): unknown {
    const obj: any = {};
    if (message.delta !== undefined) {
      obj.delta = ChoiceDelta.toJSON(message.delta);
    }
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.logprobs !== undefined) {
      obj.logprobs = ChoiceLogprobs.toJSON(message.logprobs);
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkChoice>): ChunkChoice {
    return ChunkChoice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkChoice>): ChunkChoice {
    const message = createBaseChunkChoice();
    message.delta =
      object.delta !== undefined && object.delta !== null
        ? ChoiceDelta.fromPartial(object.delta)
        : undefined;
    message.finishReason = object.finishReason ?? "";
    message.index = object.index ?? 0;
    message.logprobs =
      object.logprobs !== undefined && object.logprobs !== null
        ? ChoiceLogprobs.fromPartial(object.logprobs)
        : undefined;
    return message;
  },
};

function createBaseChoiceLogprobs(): ChoiceLogprobs {
  return { content: [], refusal: [] };
}

export const ChoiceLogprobs: MessageFns<ChoiceLogprobs> = {
  encode(
    message: ChoiceLogprobs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.content) {
      ChatCompletionTokenLogprob.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.refusal) {
      ChatCompletionTokenLogprob.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChoiceLogprobs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceLogprobs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content.push(
            ChatCompletionTokenLogprob.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refusal.push(
            ChatCompletionTokenLogprob.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceLogprobs {
    return {
      content: globalThis.Array.isArray(object?.content)
        ? object.content.map((e: any) => ChatCompletionTokenLogprob.fromJSON(e))
        : [],
      refusal: globalThis.Array.isArray(object?.refusal)
        ? object.refusal.map((e: any) => ChatCompletionTokenLogprob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChoiceLogprobs): unknown {
    const obj: any = {};
    if (message.content?.length) {
      obj.content = message.content.map(e =>
        ChatCompletionTokenLogprob.toJSON(e),
      );
    }
    if (message.refusal?.length) {
      obj.refusal = message.refusal.map(e =>
        ChatCompletionTokenLogprob.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceLogprobs>): ChoiceLogprobs {
    return ChoiceLogprobs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChoiceLogprobs>): ChoiceLogprobs {
    const message = createBaseChoiceLogprobs();
    message.content =
      object.content?.map(e => ChatCompletionTokenLogprob.fromPartial(e)) || [];
    message.refusal =
      object.refusal?.map(e => ChatCompletionTokenLogprob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChoiceDelta(): ChoiceDelta {
  return {
    content: "",
    functionCall: undefined,
    refusal: "",
    role: "",
    toolCalls: [],
  };
}

export const ChoiceDelta: MessageFns<ChoiceDelta> = {
  encode(
    message: ChoiceDelta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.functionCall !== undefined) {
      ChoiceDeltaFunctionCall.encode(
        message.functionCall,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.refusal !== "") {
      writer.uint32(26).string(message.refusal);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    for (const v of message.toolCalls) {
      ChoiceDeltaToolCall.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChoiceDelta {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.functionCall = ChoiceDeltaFunctionCall.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refusal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolCalls.push(
            ChoiceDeltaToolCall.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceDelta {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      functionCall: isSet(object.functionCall)
        ? ChoiceDeltaFunctionCall.fromJSON(object.functionCall)
        : undefined,
      refusal: isSet(object.refusal) ? globalThis.String(object.refusal) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ChoiceDeltaToolCall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChoiceDelta): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.functionCall !== undefined) {
      obj.functionCall = ChoiceDeltaFunctionCall.toJSON(message.functionCall);
    }
    if (message.refusal !== "") {
      obj.refusal = message.refusal;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map(e => ChoiceDeltaToolCall.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceDelta>): ChoiceDelta {
    return ChoiceDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChoiceDelta>): ChoiceDelta {
    const message = createBaseChoiceDelta();
    message.content = object.content ?? "";
    message.functionCall =
      object.functionCall !== undefined && object.functionCall !== null
        ? ChoiceDeltaFunctionCall.fromPartial(object.functionCall)
        : undefined;
    message.refusal = object.refusal ?? "";
    message.role = object.role ?? "";
    message.toolCalls =
      object.toolCalls?.map(e => ChoiceDeltaToolCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChoiceDeltaFunctionCall(): ChoiceDeltaFunctionCall {
  return { arguments: [], name: "" };
}

export const ChoiceDeltaFunctionCall: MessageFns<ChoiceDeltaFunctionCall> = {
  encode(
    message: ChoiceDeltaFunctionCall,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChoiceDeltaFunctionCall {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceDeltaFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceDeltaFunctionCall {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ChoiceDeltaFunctionCall): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceDeltaFunctionCall>): ChoiceDeltaFunctionCall {
    return ChoiceDeltaFunctionCall.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChoiceDeltaFunctionCall>,
  ): ChoiceDeltaFunctionCall {
    const message = createBaseChoiceDeltaFunctionCall();
    message.arguments = object.arguments?.map(e => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChoiceDeltaToolCall(): ChoiceDeltaToolCall {
  return { index: 0, id: "", function: undefined, type: "" };
}

export const ChoiceDeltaToolCall: MessageFns<ChoiceDeltaToolCall> = {
  encode(
    message: ChoiceDeltaToolCall,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int64(message.index);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.function !== undefined) {
      ChoiceDeltaToolCallFunction.encode(
        message.function,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChoiceDeltaToolCall {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceDeltaToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.function = ChoiceDeltaToolCallFunction.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceDeltaToolCall {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      function: isSet(object.function)
        ? ChoiceDeltaToolCallFunction.fromJSON(object.function)
        : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: ChoiceDeltaToolCall): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.function !== undefined) {
      obj.function = ChoiceDeltaToolCallFunction.toJSON(message.function);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceDeltaToolCall>): ChoiceDeltaToolCall {
    return ChoiceDeltaToolCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChoiceDeltaToolCall>): ChoiceDeltaToolCall {
    const message = createBaseChoiceDeltaToolCall();
    message.index = object.index ?? 0;
    message.id = object.id ?? "";
    message.function =
      object.function !== undefined && object.function !== null
        ? ChoiceDeltaToolCallFunction.fromPartial(object.function)
        : undefined;
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseChoiceDeltaToolCallFunction(): ChoiceDeltaToolCallFunction {
  return { arguments: [], name: "" };
}

export const ChoiceDeltaToolCallFunction: MessageFns<ChoiceDeltaToolCallFunction> =
  {
    encode(
      message: ChoiceDeltaToolCallFunction,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.arguments) {
        writer.uint32(10).string(v!);
      }
      if (message.name !== "") {
        writer.uint32(18).string(message.name);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChoiceDeltaToolCallFunction {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChoiceDeltaToolCallFunction();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.arguments.push(reader.string());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.name = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChoiceDeltaToolCallFunction {
      return {
        arguments: globalThis.Array.isArray(object?.arguments)
          ? object.arguments.map((e: any) => globalThis.String(e))
          : [],
        name: isSet(object.name) ? globalThis.String(object.name) : "",
      };
    },

    toJSON(message: ChoiceDeltaToolCallFunction): unknown {
      const obj: any = {};
      if (message.arguments?.length) {
        obj.arguments = message.arguments;
      }
      if (message.name !== "") {
        obj.name = message.name;
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChoiceDeltaToolCallFunction>,
    ): ChoiceDeltaToolCallFunction {
      return ChoiceDeltaToolCallFunction.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChoiceDeltaToolCallFunction>,
    ): ChoiceDeltaToolCallFunction {
      const message = createBaseChoiceDeltaToolCallFunction();
      message.arguments = object.arguments?.map(e => e) || [];
      message.name = object.name ?? "";
      return message;
    },
  };

function createBaseChatCompletionTokenLogprob(): ChatCompletionTokenLogprob {
  return { token: "", bytes: [], logprob: 0, topLogprobs: [] };
}

export const ChatCompletionTokenLogprob: MessageFns<ChatCompletionTokenLogprob> =
  {
    encode(
      message: ChatCompletionTokenLogprob,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.token !== "") {
        writer.uint32(10).string(message.token);
      }
      writer.uint32(18).fork();
      for (const v of message.bytes) {
        writer.int64(v);
      }
      writer.join();
      if (message.logprob !== 0) {
        writer.uint32(25).double(message.logprob);
      }
      for (const v of message.topLogprobs) {
        TopLogprob.encode(v!, writer.uint32(34).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChatCompletionTokenLogprob {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChatCompletionTokenLogprob();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.token = reader.string();
            continue;
          }
          case 2: {
            if (tag === 16) {
              message.bytes.push(longToNumber(reader.int64()));

              continue;
            }

            if (tag === 18) {
              const end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {
                message.bytes.push(longToNumber(reader.int64()));
              }

              continue;
            }

            break;
          }
          case 3: {
            if (tag !== 25) {
              break;
            }

            message.logprob = reader.double();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.topLogprobs.push(
              TopLogprob.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChatCompletionTokenLogprob {
      return {
        token: isSet(object.token) ? globalThis.String(object.token) : "",
        bytes: globalThis.Array.isArray(object?.bytes)
          ? object.bytes.map((e: any) => globalThis.Number(e))
          : [],
        logprob: isSet(object.logprob) ? globalThis.Number(object.logprob) : 0,
        topLogprobs: globalThis.Array.isArray(object?.topLogprobs)
          ? object.topLogprobs.map((e: any) => TopLogprob.fromJSON(e))
          : [],
      };
    },

    toJSON(message: ChatCompletionTokenLogprob): unknown {
      const obj: any = {};
      if (message.token !== "") {
        obj.token = message.token;
      }
      if (message.bytes?.length) {
        obj.bytes = message.bytes.map(e => Math.round(e));
      }
      if (message.logprob !== 0) {
        obj.logprob = message.logprob;
      }
      if (message.topLogprobs?.length) {
        obj.topLogprobs = message.topLogprobs.map(e => TopLogprob.toJSON(e));
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChatCompletionTokenLogprob>,
    ): ChatCompletionTokenLogprob {
      return ChatCompletionTokenLogprob.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChatCompletionTokenLogprob>,
    ): ChatCompletionTokenLogprob {
      const message = createBaseChatCompletionTokenLogprob();
      message.token = object.token ?? "";
      message.bytes = object.bytes?.map(e => e) || [];
      message.logprob = object.logprob ?? 0;
      message.topLogprobs =
        object.topLogprobs?.map(e => TopLogprob.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseTopLogprob(): TopLogprob {
  return { token: "", bytes: [], logprob: 0 };
}

export const TopLogprob: MessageFns<TopLogprob> = {
  encode(
    message: TopLogprob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    writer.uint32(18).fork();
    for (const v of message.bytes) {
      writer.int64(v);
    }
    writer.join();
    if (message.logprob !== 0) {
      writer.uint32(25).double(message.logprob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopLogprob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopLogprob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.bytes.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bytes.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.logprob = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopLogprob {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      bytes: globalThis.Array.isArray(object?.bytes)
        ? object.bytes.map((e: any) => globalThis.Number(e))
        : [],
      logprob: isSet(object.logprob) ? globalThis.Number(object.logprob) : 0,
    };
  },

  toJSON(message: TopLogprob): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.bytes?.length) {
      obj.bytes = message.bytes.map(e => Math.round(e));
    }
    if (message.logprob !== 0) {
      obj.logprob = message.logprob;
    }
    return obj;
  },

  create(base?: DeepPartial<TopLogprob>): TopLogprob {
    return TopLogprob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopLogprob>): TopLogprob {
    const message = createBaseTopLogprob();
    message.token = object.token ?? "";
    message.bytes = object.bytes?.map(e => e) || [];
    message.logprob = object.logprob ?? 0;
    return message;
  },
};

function createBaseCompletionUsage(): CompletionUsage {
  return {
    completionTokens: 0,
    promptTokens: 0,
    totalTokens: 0,
    completionTokensDetails: undefined,
    promptTokensDetails: undefined,
  };
}

export const CompletionUsage: MessageFns<CompletionUsage> = {
  encode(
    message: CompletionUsage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.completionTokens !== 0) {
      writer.uint32(8).int64(message.completionTokens);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(16).int64(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int64(message.totalTokens);
    }
    if (message.completionTokensDetails !== undefined) {
      CompletionTokensDetails.encode(
        message.completionTokensDetails,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.promptTokensDetails !== undefined) {
      PromptTokensDetails.encode(
        message.promptTokensDetails,
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletionUsage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completionTokensDetails = CompletionTokensDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.promptTokensDetails = PromptTokensDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionUsage {
    return {
      completionTokens: isSet(object.completionTokens)
        ? globalThis.Number(object.completionTokens)
        : 0,
      promptTokens: isSet(object.promptTokens)
        ? globalThis.Number(object.promptTokens)
        : 0,
      totalTokens: isSet(object.totalTokens)
        ? globalThis.Number(object.totalTokens)
        : 0,
      completionTokensDetails: isSet(object.completionTokensDetails)
        ? CompletionTokensDetails.fromJSON(object.completionTokensDetails)
        : undefined,
      promptTokensDetails: isSet(object.promptTokensDetails)
        ? PromptTokensDetails.fromJSON(object.promptTokensDetails)
        : undefined,
    };
  },

  toJSON(message: CompletionUsage): unknown {
    const obj: any = {};
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.completionTokensDetails !== undefined) {
      obj.completionTokensDetails = CompletionTokensDetails.toJSON(
        message.completionTokensDetails,
      );
    }
    if (message.promptTokensDetails !== undefined) {
      obj.promptTokensDetails = PromptTokensDetails.toJSON(
        message.promptTokensDetails,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionUsage>): CompletionUsage {
    return CompletionUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompletionUsage>): CompletionUsage {
    const message = createBaseCompletionUsage();
    message.completionTokens = object.completionTokens ?? 0;
    message.promptTokens = object.promptTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.completionTokensDetails =
      object.completionTokensDetails !== undefined &&
      object.completionTokensDetails !== null
        ? CompletionTokensDetails.fromPartial(object.completionTokensDetails)
        : undefined;
    message.promptTokensDetails =
      object.promptTokensDetails !== undefined &&
      object.promptTokensDetails !== null
        ? PromptTokensDetails.fromPartial(object.promptTokensDetails)
        : undefined;
    return message;
  },
};

function createBaseCompletionTokensDetails(): CompletionTokensDetails {
  return {
    acceptedPredictionTokens: 0,
    audioTokens: 0,
    reasoningTokens: 0,
    rejectedPredictionTokens: 0,
  };
}

export const CompletionTokensDetails: MessageFns<CompletionTokensDetails> = {
  encode(
    message: CompletionTokensDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.acceptedPredictionTokens !== 0) {
      writer.uint32(8).int64(message.acceptedPredictionTokens);
    }
    if (message.audioTokens !== 0) {
      writer.uint32(16).int64(message.audioTokens);
    }
    if (message.reasoningTokens !== 0) {
      writer.uint32(24).int64(message.reasoningTokens);
    }
    if (message.rejectedPredictionTokens !== 0) {
      writer.uint32(32).int64(message.rejectedPredictionTokens);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CompletionTokensDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionTokensDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.acceptedPredictionTokens = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.audioTokens = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reasoningTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rejectedPredictionTokens = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionTokensDetails {
    return {
      acceptedPredictionTokens: isSet(object.acceptedPredictionTokens)
        ? globalThis.Number(object.acceptedPredictionTokens)
        : 0,
      audioTokens: isSet(object.audioTokens)
        ? globalThis.Number(object.audioTokens)
        : 0,
      reasoningTokens: isSet(object.reasoningTokens)
        ? globalThis.Number(object.reasoningTokens)
        : 0,
      rejectedPredictionTokens: isSet(object.rejectedPredictionTokens)
        ? globalThis.Number(object.rejectedPredictionTokens)
        : 0,
    };
  },

  toJSON(message: CompletionTokensDetails): unknown {
    const obj: any = {};
    if (message.acceptedPredictionTokens !== 0) {
      obj.acceptedPredictionTokens = Math.round(
        message.acceptedPredictionTokens,
      );
    }
    if (message.audioTokens !== 0) {
      obj.audioTokens = Math.round(message.audioTokens);
    }
    if (message.reasoningTokens !== 0) {
      obj.reasoningTokens = Math.round(message.reasoningTokens);
    }
    if (message.rejectedPredictionTokens !== 0) {
      obj.rejectedPredictionTokens = Math.round(
        message.rejectedPredictionTokens,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionTokensDetails>): CompletionTokensDetails {
    return CompletionTokensDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CompletionTokensDetails>,
  ): CompletionTokensDetails {
    const message = createBaseCompletionTokensDetails();
    message.acceptedPredictionTokens = object.acceptedPredictionTokens ?? 0;
    message.audioTokens = object.audioTokens ?? 0;
    message.reasoningTokens = object.reasoningTokens ?? 0;
    message.rejectedPredictionTokens = object.rejectedPredictionTokens ?? 0;
    return message;
  },
};

function createBasePromptTokensDetails(): PromptTokensDetails {
  return { audioTokens: 0, cachedTokens: 0 };
}

export const PromptTokensDetails: MessageFns<PromptTokensDetails> = {
  encode(
    message: PromptTokensDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.audioTokens !== 0) {
      writer.uint32(8).int64(message.audioTokens);
    }
    if (message.cachedTokens !== 0) {
      writer.uint32(16).int64(message.cachedTokens);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PromptTokensDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptTokensDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioTokens = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cachedTokens = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptTokensDetails {
    return {
      audioTokens: isSet(object.audioTokens)
        ? globalThis.Number(object.audioTokens)
        : 0,
      cachedTokens: isSet(object.cachedTokens)
        ? globalThis.Number(object.cachedTokens)
        : 0,
    };
  },

  toJSON(message: PromptTokensDetails): unknown {
    const obj: any = {};
    if (message.audioTokens !== 0) {
      obj.audioTokens = Math.round(message.audioTokens);
    }
    if (message.cachedTokens !== 0) {
      obj.cachedTokens = Math.round(message.cachedTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<PromptTokensDetails>): PromptTokensDetails {
    return PromptTokensDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PromptTokensDetails>): PromptTokensDetails {
    const message = createBasePromptTokensDetails();
    message.audioTokens = object.audioTokens ?? 0;
    message.cachedTokens = object.cachedTokens ?? 0;
    return message;
  },
};

function createBaseWebRetrievalRequest(): WebRetrievalRequest {
  return {
    uids: [],
    searchQuery: "",
    nMiners: undefined,
    nResults: undefined,
    maxResponseTime: undefined,
    timeout: undefined,
  };
}

export const WebRetrievalRequest: MessageFns<WebRetrievalRequest> = {
  encode(
    message: WebRetrievalRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.uids) {
      writer.int64(v);
    }
    writer.join();
    if (message.searchQuery !== "") {
      writer.uint32(18).string(message.searchQuery);
    }
    if (message.nMiners !== undefined) {
      writer.uint32(24).int64(message.nMiners);
    }
    if (message.nResults !== undefined) {
      writer.uint32(32).int64(message.nResults);
    }
    if (message.maxResponseTime !== undefined) {
      writer.uint32(40).int64(message.maxResponseTime);
    }
    if (message.timeout !== undefined) {
      writer.uint32(48).int64(message.timeout);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebRetrievalRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebRetrievalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.uids.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uids.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nMiners = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nResults = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxResponseTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timeout = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebRetrievalRequest {
    return {
      uids: globalThis.Array.isArray(object?.uids)
        ? object.uids.map((e: any) => globalThis.Number(e))
        : [],
      searchQuery: isSet(object.searchQuery)
        ? globalThis.String(object.searchQuery)
        : "",
      nMiners: isSet(object.nMiners)
        ? globalThis.Number(object.nMiners)
        : undefined,
      nResults: isSet(object.nResults)
        ? globalThis.Number(object.nResults)
        : undefined,
      maxResponseTime: isSet(object.maxResponseTime)
        ? globalThis.Number(object.maxResponseTime)
        : undefined,
      timeout: isSet(object.timeout)
        ? globalThis.Number(object.timeout)
        : undefined,
    };
  },

  toJSON(message: WebRetrievalRequest): unknown {
    const obj: any = {};
    if (message.uids?.length) {
      obj.uids = message.uids.map(e => Math.round(e));
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.nMiners !== undefined) {
      obj.nMiners = Math.round(message.nMiners);
    }
    if (message.nResults !== undefined) {
      obj.nResults = Math.round(message.nResults);
    }
    if (message.maxResponseTime !== undefined) {
      obj.maxResponseTime = Math.round(message.maxResponseTime);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Math.round(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<WebRetrievalRequest>): WebRetrievalRequest {
    return WebRetrievalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebRetrievalRequest>): WebRetrievalRequest {
    const message = createBaseWebRetrievalRequest();
    message.uids = object.uids?.map(e => e) || [];
    message.searchQuery = object.searchQuery ?? "";
    message.nMiners = object.nMiners ?? undefined;
    message.nResults = object.nResults ?? undefined;
    message.maxResponseTime = object.maxResponseTime ?? undefined;
    message.timeout = object.timeout ?? undefined;
    return message;
  },
};

function createBaseWebSearchResult(): WebSearchResult {
  return { url: "", content: "", relevant: "" };
}

export const WebSearchResult: MessageFns<WebSearchResult> = {
  encode(
    message: WebSearchResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.relevant !== "") {
      writer.uint32(26).string(message.relevant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebSearchResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relevant = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebSearchResult {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      relevant: isSet(object.relevant)
        ? globalThis.String(object.relevant)
        : "",
    };
  },

  toJSON(message: WebSearchResult): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.relevant !== "") {
      obj.relevant = message.relevant;
    }
    return obj;
  },

  create(base?: DeepPartial<WebSearchResult>): WebSearchResult {
    return WebSearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebSearchResult>): WebSearchResult {
    const message = createBaseWebSearchResult();
    message.url = object.url ?? "";
    message.content = object.content ?? "";
    message.relevant = object.relevant ?? "";
    return message;
  },
};

function createBaseWebRetrievalResponse(): WebRetrievalResponse {
  return { results: [] };
}

export const WebRetrievalResponse: MessageFns<WebRetrievalResponse> = {
  encode(
    message: WebRetrievalResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.results) {
      WebSearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebRetrievalResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebRetrievalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(WebSearchResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebRetrievalResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => WebSearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebRetrievalResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map(e => WebSearchResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebRetrievalResponse>): WebRetrievalResponse {
    return WebRetrievalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebRetrievalResponse>): WebRetrievalResponse {
    const message = createBaseWebRetrievalResponse();
    message.results =
      object.results?.map(e => WebSearchResult.fromPartial(e)) || [];
    return message;
  },
};

export type ApexServiceService = typeof ApexServiceService;
export const ApexServiceService = {
  /** ChatCompletion generates a completion for a given request. */
  chatCompletion: {
    path: "/apex.v1.ApexService/ChatCompletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChatCompletionRequest) =>
      Buffer.from(ChatCompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatCompletionRequest.decode(value),
    responseSerialize: (value: ChatCompletionResponse) =>
      Buffer.from(ChatCompletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ChatCompletionResponse.decode(value),
  },
  /** ChatCompletionStream generates a stream of completions for a given request. */
  chatCompletionStream: {
    path: "/apex.v1.ApexService/ChatCompletionStream",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ChatCompletionRequest) =>
      Buffer.from(ChatCompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatCompletionRequest.decode(value),
    responseSerialize: (value: ChatCompletionChunkResponse) =>
      Buffer.from(ChatCompletionChunkResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ChatCompletionChunkResponse.decode(value),
  },
  /** WebRetrieval retrieves web search results for a given request. */
  webRetrieval: {
    path: "/apex.v1.ApexService/WebRetrieval",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WebRetrievalRequest) =>
      Buffer.from(WebRetrievalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WebRetrievalRequest.decode(value),
    responseSerialize: (value: WebRetrievalResponse) =>
      Buffer.from(WebRetrievalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WebRetrievalResponse.decode(value),
  },
} as const;

export interface ApexServiceServer extends UntypedServiceImplementation {
  /** ChatCompletion generates a completion for a given request. */
  chatCompletion: handleUnaryCall<
    ChatCompletionRequest,
    ChatCompletionResponse
  >;
  /** ChatCompletionStream generates a stream of completions for a given request. */
  chatCompletionStream: handleServerStreamingCall<
    ChatCompletionRequest,
    ChatCompletionChunkResponse
  >;
  /** WebRetrieval retrieves web search results for a given request. */
  webRetrieval: handleUnaryCall<WebRetrievalRequest, WebRetrievalResponse>;
}

export interface ApexServiceClient extends Client {
  /** ChatCompletion generates a completion for a given request. */
  chatCompletion(
    request: ChatCompletionRequest,
    callback: (
      error: ServiceError | null,
      response: ChatCompletionResponse,
    ) => void,
  ): ClientUnaryCall;
  chatCompletion(
    request: ChatCompletionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ChatCompletionResponse,
    ) => void,
  ): ClientUnaryCall;
  chatCompletion(
    request: ChatCompletionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ChatCompletionResponse,
    ) => void,
  ): ClientUnaryCall;
  /** ChatCompletionStream generates a stream of completions for a given request. */
  chatCompletionStream(
    request: ChatCompletionRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ChatCompletionChunkResponse>;
  chatCompletionStream(
    request: ChatCompletionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ChatCompletionChunkResponse>;
  /** WebRetrieval retrieves web search results for a given request. */
  webRetrieval(
    request: WebRetrievalRequest,
    callback: (
      error: ServiceError | null,
      response: WebRetrievalResponse,
    ) => void,
  ): ClientUnaryCall;
  webRetrieval(
    request: WebRetrievalRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: WebRetrievalResponse,
    ) => void,
  ): ClientUnaryCall;
  webRetrieval(
    request: WebRetrievalRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: WebRetrievalResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const ApexServiceClient = makeGenericClientConstructor(
  ApexServiceService,
  "apex.v1.ApexService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): ApexServiceClient;
  service: typeof ApexServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
