// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: apex/v1/apex.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../google/protobuf/empty";
import { Struct } from "../../google/protobuf/struct";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "apex.v1";

/**
 * A request to generate completions following Apex CompletionsRequest format.
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface ChatCompletionRequest {
  /** uids: the miner UIDs that will be used to generate the completion (optional). */
  uids: number[];
  /** messages: the messages to generate completions for. */
  messages: ChatMessage[];
  /** seed: the seed to use for the completion. */
  seed?: number | undefined;
  /** task: the task to generate completions for (e.g. "InferenceTask"). */
  task?: string | undefined;
  /** model: the LLM name to use for the completion. (optional, suggest leaving this empty as not all LLMs are supported) */
  model?: string | undefined;
  /** test_time_inference: whether to use test time inference. */
  testTimeInference?: boolean | undefined;
  /** mixture: whether to use a mixture of miners to create a slower but better answer. */
  mixture?: boolean | undefined;
  /** sampling_parameters: the sampling parameters to use for the completion. */
  samplingParameters?: SamplingParameters | undefined;
  /** inference_mode: the inference mode to use for the completion. */
  inferenceMode?: string | undefined;
  /** json_format: whether to use JSON format for the completion. */
  jsonFormat?: boolean | undefined;
  /** stream: whether to stream the completion. */
  stream?: boolean | undefined;
  /** timeout: the timeout for the completion in seconds. */
  timeout?: number | undefined;
}

/**
 * The sampling parameters for the completion.
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface SamplingParameters {
  /** temperature: the temperature to use for the completion. */
  temperature: number;
  /** top_p: the top_p to use for the completion. */
  topP: number;
  /** top_k: the top_k to use for the completion. */
  topK?: number | undefined;
  /** max_new_tokens: the max_new_tokens to use for the completion. */
  maxNewTokens: number;
  /** do_sample: whether to do sample for the completion. */
  doSample: boolean;
}

/**
 * A chat completion response, following OpenAI's ChatCompletion format.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion.py
 */
export interface ChatCompletionResponse {
  /** id: the id of the completion. */
  id: string;
  /** choices: the choices of the completion. */
  choices: Choice[];
  /** created: the created time of the completion. */
  created: number;
  /** model: the model of the completion. */
  model: string;
  /** object: the object of the completion. */
  object: string;
  /** service_tier: the service tier of the completion. (not currently supported in Apex) */
  serviceTier: string;
  /** system_fingerprint: the system fingerprint of the completion. (not currently supported in Apex) */
  systemFingerprint: string;
  /** usage: the usage of the completion. (not currently supported in Apex) */
  usage?: CompletionUsage | undefined;
}

/**
 * The choice object containing the message response from the LLM for the completion.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion.py
 */
export interface Choice {
  /** finish_reason: the finish reason of the choice. */
  finishReason: string;
  /** index: the index of the choice. */
  index: number;
  /** logprobs: the logprobs of the choice. */
  logprobs?: ChoiceLogprobs | undefined;
  /** message: the message of the choice. */
  message?: ChatCompletionMessage | undefined;
}

/**
 * The message response object from the LLM.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message.py
 */
export interface ChatCompletionMessage {
  /** content: the content of the message. */
  content: string;
  /** refusal: the refusal of the message. (not currently supported in Apex) */
  refusal: string;
  /** role: the role of the message. */
  role: string;
  /** annotations: the annotations of the message. (not currently supported in Apex) */
  annotations: Annotation[];
  /** audio: the audio of the message. (not currently supported in Apex) */
  audio?: ChatCompletionAudio | undefined;
  /** function_call: the function call of the message. */
  functionCall?: FunctionCall | undefined;
  /** tool_calls: the tool calls of the message. */
  toolCalls: ChatCompletionMessageToolCall[];
}

/**
 * The annotation object for the message. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message.py
 */
export interface Annotation {
  /** content: the content of the annotation. */
  content: string;
  /** role: the role of the annotation. */
  role: string;
}

/**
 * The audio object for the message. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_audio.py
 */
export interface ChatCompletionAudio {
  /** id: the id of the audio. */
  id: string;
  /** data: the data of the audio. */
  data: string;
  /** expires_at: the expires at of the audio. */
  expiresAt: number;
  /** transcript: the transcript of the audio. */
  transcript: string;
}

/**
 * The function call object for the message.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message.py
 */
export interface FunctionCall {
  /** arguments: the arguments of the function call. */
  arguments: string[];
  /** name: the name of the function call. */
  name: string;
}

/**
 * The tool call object for the message.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message_tool_call.py
 */
export interface ChatCompletionMessageToolCall {
  /** id: the id of the tool call. */
  id: string;
  /** function: the function object for the tool call. */
  function?: FunctionMessage | undefined;
  /** type: the type of the tool call. */
  type: string;
}

/**
 * The function object for the tool call.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_message_tool_call.py
 */
export interface FunctionMessage {
  /** arguments: the arguments of the function. */
  arguments: string[];
  /** name: the name of the function. */
  name: string;
}

/**
 * A streaming chunk response, following OpenAI's ChatCompletionChunk format.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChatCompletionChunkResponse {
  /** id: the id of the chunk. */
  id: string;
  /** choices: the choices of the chunk. */
  choices: ChunkChoice[];
  /** created: the created time of the chunk. */
  created: number;
  /** model: the model of the chunk. */
  model: string;
  /** object: the object of the chunk. (not currently supported in Apex) */
  object: string;
  /** service_tier: the service tier of the chunk. (not currently supported in Apex) */
  serviceTier: string;
  /** system_fingerprint: the system fingerprint of the chunk. (not currently supported in Apex) */
  systemFingerprint: string;
  /** usage: the usage of the chunk. (not currently supported in Apex) */
  usage?: CompletionUsage | undefined;
}

/**
 * The choice object for the chunk.
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface ChatMessage {
  /** role: the role of the message. */
  role: string;
  /** content: the content of the message. */
  content: string;
}

/**
 * The choice object for the chunk.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChunkChoice {
  /** delta: the delta of the choice. */
  delta?: ChoiceDelta | undefined;
  /** finish_reason: the finish reason of the choice. */
  finishReason: string;
  /** index: the index of the choice. */
  index: number;
  /** logprobs: the logprobs of the choice. (not currently supported in Apex) */
  logprobs?: ChoiceLogprobs | undefined;
}

/**
 * The logprobs object for the choice.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceLogprobs {
  /** content: the content of the logprobs. */
  content: ChatCompletionTokenLogprob[];
  /** refusal: the refusal of the logprobs. */
  refusal: ChatCompletionTokenLogprob[];
}

/**
 * The delta object for the choice.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDelta {
  /** content: the content of the delta. */
  content: string;
  /** function_call: the function call of the delta. */
  functionCall?: ChoiceDeltaFunctionCall | undefined;
  /** refusal: the refusal of the delta. */
  refusal: string;
  /** role: the role of the delta. */
  role: string;
  /** tool_calls: the tool calls of the delta. */
  toolCalls: ChoiceDeltaToolCall[];
}

/**
 * The function call object for the delta.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDeltaFunctionCall {
  /** arguments: the arguments of the function call. */
  arguments: string[];
  /** name: the name of the function call. */
  name: string;
}

/**
 * The tool call object for the delta.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDeltaToolCall {
  /** index: the index of the tool call. */
  index: number;
  /** id: the id of the tool call. */
  id: string;
  /** function: the function object for the tool call. */
  function?: ChoiceDeltaToolCallFunction | undefined;
  /** type: the type of the tool call. */
  type: string;
}

/**
 * The function object for the tool call.
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_chunk.py
 */
export interface ChoiceDeltaToolCallFunction {
  /** arguments: the arguments of the function. */
  arguments: string[];
  /** name: the name of the function. */
  name: string;
}

/**
 * The chat completion token logprob object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_token_logprob.py
 */
export interface ChatCompletionTokenLogprob {
  /** token: the token of the logprob. */
  token: string;
  /** bytes: the bytes of the logprob. */
  bytes: number[];
  /** logprob: the logprob of the token. */
  logprob: number;
  /** top_logprobs: the top logprobs of the token. */
  topLogprobs: TopLogprob[];
}

/**
 * The top logprob object for the token. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/chat/chat_completion_token_logprob.py
 */
export interface TopLogprob {
  /** token: the token of the logprob. */
  token: string;
  /** bytes: the bytes of the logprob. */
  bytes: number[];
  /** logprob: the logprob of the token. */
  logprob: number;
}

/**
 * The completion usage object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/completion_usage.py
 */
export interface CompletionUsage {
  /** completion_tokens: the completion tokens of the usage. */
  completionTokens: number;
  /** prompt_tokens: the prompt tokens of the usage. */
  promptTokens: number;
  /** total_tokens: the total tokens of the usage. */
  totalTokens: number;
  /** completion_tokens_details: the completion tokens details of the usage. */
  completionTokensDetails?: CompletionTokensDetails | undefined;
  /** prompt_tokens_details: the prompt tokens details of the usage. */
  promptTokensDetails?: PromptTokensDetails | undefined;
}

/**
 * The completion tokens details object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/completion_usage.py
 */
export interface CompletionTokensDetails {
  /** accepted_prediction_tokens: the accepted prediction tokens of the details. */
  acceptedPredictionTokens: number;
  /** audio_tokens: the audio tokens of the details. */
  audioTokens: number;
  /** reasoning_tokens: the reasoning tokens of the details. */
  reasoningTokens: number;
  /** rejected_prediction_tokens: the rejected prediction tokens of the details. */
  rejectedPredictionTokens: number;
}

/**
 * The prompt tokens details object. (not currently supported in Apex)
 * Parsed from https://github.com/openai/openai-python/blob/main/src/openai/types/completion_usage.py
 */
export interface PromptTokensDetails {
  /** audio_tokens: the audio tokens of the details. */
  audioTokens: number;
  /** cached_tokens: the cached tokens of the details. */
  cachedTokens: number;
}

/**
 * A web retrieval request from Apex
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface WebRetrievalRequest {
  /** uids: the miner UIDs that will be used to generate the completion (optional). */
  uids: number[];
  /** search_query: the search query. */
  searchQuery: string;
  /** n_miners: the number of miners to use for the query. */
  nMiners?: number | undefined;
  /** n_results: the number of results to return. */
  nResults?: number | undefined;
  /** max_response_time: the max response time to allow for the miners to respond in seconds. */
  maxResponseTime?: number | undefined;
  /** timeout: the timeout for the web retrieval in seconds. */
  timeout?: number | undefined;
}

/**
 * A web search result from Apex
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface WebSearchResult {
  /** url: the url of the result. */
  url: string;
  /** content: the entire page contents. */
  content: string;
  /** relevant: the relevant part of the page best fitting the query.. */
  relevant: string;
}

/**
 * A web retrieval response from Apex
 * Parsed from https://github.com/macrocosm-os/prompting/blob/main/validator_api/serializers.py
 */
export interface WebRetrievalResponse {
  /** results: the results of the web retrieval. */
  results: WebSearchResult[];
}

/** A response containing the deep researcher job submission details */
export interface SubmitDeepResearcherJobResponse {
  /** job_id: unique identifier for the submitted job */
  jobId: string;
  /** status: current status of the job */
  status: string;
  /** created_at: timestamp when the job was created */
  createdAt: string;
  /** updated_at: timestamp when the job was last updated */
  updatedAt: string;
}

/** A response containing the deep researcher job status and results */
export interface GetDeepResearcherJobResponse {
  /** job_id: unique identifier for the job */
  jobId: string;
  /** status: current status of the job */
  status: string;
  /** created_at: timestamp when the job was created */
  createdAt: string;
  /** updated_at: timestamp when the job was last updated */
  updatedAt: string;
  /** result: array of result chunks */
  result: DeepResearcherResultChunk[];
  /** error: error message if the job failed */
  error?: string | undefined;
}

/** A chunk of the deep researcher result */
export interface DeepResearcherResultChunk {
  /** seq_id: sequence identifier for the chunk */
  seqId: number;
  /** chunk: the content of the chunk */
  chunk: string;
}

/** A request to get the status of a deep researcher job */
export interface GetDeepResearcherJobRequest {
  /** job_id: the ID of the job to retrieve */
  jobId: string;
}

/** A GetChatSession message repeated in GetChatSessionsResponse */
export interface ChatSession {
  /** id: chat id */
  id: string;
  /** user_id: user id */
  userId: string;
  /** title: title of chat */
  title: string;
  /** chat_type: e.g. apex */
  chatType: string;
  /** created_at: when the chat was created */
  createdAt?: Date | undefined;
  /** updated_at: when the chat was updated */
  updatedAt?: Date | undefined;
}

/** A GetChatSessionsResponse response */
export interface GetChatSessionsResponse {
  /** chat_sessions: the chat sessions */
  chatSessions: ChatSession[];
}

/** A GetStoredChatCompletionRequest request message */
export interface GetStoredChatCompletionsRequest {
  /** chat_id: a unique identifier for a chat */
  chatId: string;
}

/** A StoredChatCompletion message repeated in GetStoredChatCompletionsResponse */
export interface StoredChatCompletion {
  /** id: chat completion id */
  id: string;
  /** chat_id: chat id */
  chatId: string;
  /** completion_type: type of completion */
  completionType: string;
  /** created_at: when the chat was created */
  createdAt?: Date | undefined;
  /** completed_at: when the chat was updated */
  completedAt?: Date | undefined;
  /** user_prompt_text: user_prompt_text of chat */
  userPromptText: string;
  /** completion_text: completion_text of chat */
  completionText: string;
  /** metadata: metadata json blob */
  metadata?: { [key: string]: any } | undefined;
  /** error_message: error_message if any */
  errorMessage: string;
}

/** A GetChatStoredChatCompletionResponse response */
export interface GetStoredChatCompletionsResponse {
  /** chat_completions: the chat completions */
  chatCompletions: StoredChatCompletion[];
}

/** Directly model the attributes as a map */
export interface UpdateChatAttributeRequest {
  /** chat_id: the unique id associated to a users chat message */
  chatId: string;
  /** attributes: the data attributes captured in the chat logging process */
  attributes: { [key: string]: string };
}

export interface UpdateChatAttributeRequest_AttributesEntry {
  key: string;
  value: string;
}

/** A UpdateChatAttribute response */
export interface UpdateChatAttributeResponse {
  /** success: indicates if an attribute update was successful */
  success: boolean;
}

/** A DeleteChats request */
export interface DeleteChatsRequest {
  /** chat_ids: the unique ids associated to user chat messages that should be deleted */
  chatIds: string[];
}

/** A DeleteChats response */
export interface DeleteChatsResponse {
  /** success: indicates if the deletion was successful */
  success: boolean;
}

function createBaseChatCompletionRequest(): ChatCompletionRequest {
  return {
    uids: [],
    messages: [],
    seed: undefined,
    task: undefined,
    model: undefined,
    testTimeInference: undefined,
    mixture: undefined,
    samplingParameters: undefined,
    inferenceMode: undefined,
    jsonFormat: undefined,
    stream: undefined,
    timeout: undefined,
  };
}

export const ChatCompletionRequest: MessageFns<ChatCompletionRequest> = {
  encode(
    message: ChatCompletionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.uids) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.seed !== undefined) {
      writer.uint32(24).int64(message.seed);
    }
    if (message.task !== undefined) {
      writer.uint32(34).string(message.task);
    }
    if (message.model !== undefined) {
      writer.uint32(42).string(message.model);
    }
    if (message.testTimeInference !== undefined) {
      writer.uint32(48).bool(message.testTimeInference);
    }
    if (message.mixture !== undefined) {
      writer.uint32(56).bool(message.mixture);
    }
    if (message.samplingParameters !== undefined) {
      SamplingParameters.encode(
        message.samplingParameters,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.inferenceMode !== undefined) {
      writer.uint32(74).string(message.inferenceMode);
    }
    if (message.jsonFormat !== undefined) {
      writer.uint32(80).bool(message.jsonFormat);
    }
    if (message.stream !== undefined) {
      writer.uint32(88).bool(message.stream);
    }
    if (message.timeout !== undefined) {
      writer.uint32(96).int64(message.timeout);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.uids.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uids.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.seed = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.task = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.testTimeInference = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mixture = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.samplingParameters = SamplingParameters.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.inferenceMode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.jsonFormat = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.stream = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.timeout = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionRequest {
    return {
      uids: globalThis.Array.isArray(object?.uids)
        ? object.uids.map((e: any) => globalThis.Number(e))
        : [],
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
      seed: isSet(object.seed) ? globalThis.Number(object.seed) : undefined,
      task: isSet(object.task) ? globalThis.String(object.task) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      testTimeInference: isSet(object.testTimeInference)
        ? globalThis.Boolean(object.testTimeInference)
        : undefined,
      mixture: isSet(object.mixture)
        ? globalThis.Boolean(object.mixture)
        : undefined,
      samplingParameters: isSet(object.samplingParameters)
        ? SamplingParameters.fromJSON(object.samplingParameters)
        : undefined,
      inferenceMode: isSet(object.inferenceMode)
        ? globalThis.String(object.inferenceMode)
        : undefined,
      jsonFormat: isSet(object.jsonFormat)
        ? globalThis.Boolean(object.jsonFormat)
        : undefined,
      stream: isSet(object.stream)
        ? globalThis.Boolean(object.stream)
        : undefined,
      timeout: isSet(object.timeout)
        ? globalThis.Number(object.timeout)
        : undefined,
    };
  },

  toJSON(message: ChatCompletionRequest): unknown {
    const obj: any = {};
    if (message.uids?.length) {
      obj.uids = message.uids.map(e => Math.round(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map(e => ChatMessage.toJSON(e));
    }
    if (message.seed !== undefined) {
      obj.seed = Math.round(message.seed);
    }
    if (message.task !== undefined) {
      obj.task = message.task;
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.testTimeInference !== undefined) {
      obj.testTimeInference = message.testTimeInference;
    }
    if (message.mixture !== undefined) {
      obj.mixture = message.mixture;
    }
    if (message.samplingParameters !== undefined) {
      obj.samplingParameters = SamplingParameters.toJSON(
        message.samplingParameters,
      );
    }
    if (message.inferenceMode !== undefined) {
      obj.inferenceMode = message.inferenceMode;
    }
    if (message.jsonFormat !== undefined) {
      obj.jsonFormat = message.jsonFormat;
    }
    if (message.stream !== undefined) {
      obj.stream = message.stream;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Math.round(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionRequest>): ChatCompletionRequest {
    return ChatCompletionRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChatCompletionRequest>,
  ): ChatCompletionRequest {
    const message = createBaseChatCompletionRequest();
    message.uids = object.uids?.map(e => e) || [];
    message.messages =
      object.messages?.map(e => ChatMessage.fromPartial(e)) || [];
    message.seed = object.seed ?? undefined;
    message.task = object.task ?? undefined;
    message.model = object.model ?? undefined;
    message.testTimeInference = object.testTimeInference ?? undefined;
    message.mixture = object.mixture ?? undefined;
    message.samplingParameters =
      object.samplingParameters !== undefined &&
      object.samplingParameters !== null
        ? SamplingParameters.fromPartial(object.samplingParameters)
        : undefined;
    message.inferenceMode = object.inferenceMode ?? undefined;
    message.jsonFormat = object.jsonFormat ?? undefined;
    message.stream = object.stream ?? undefined;
    message.timeout = object.timeout ?? undefined;
    return message;
  },
};

function createBaseSamplingParameters(): SamplingParameters {
  return {
    temperature: 0,
    topP: 0,
    topK: undefined,
    maxNewTokens: 0,
    doSample: false,
  };
}

export const SamplingParameters: MessageFns<SamplingParameters> = {
  encode(
    message: SamplingParameters,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.temperature !== 0) {
      writer.uint32(9).double(message.temperature);
    }
    if (message.topP !== 0) {
      writer.uint32(17).double(message.topP);
    }
    if (message.topK !== undefined) {
      writer.uint32(25).double(message.topK);
    }
    if (message.maxNewTokens !== 0) {
      writer.uint32(32).int64(message.maxNewTokens);
    }
    if (message.doSample !== false) {
      writer.uint32(40).bool(message.doSample);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SamplingParameters {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamplingParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.temperature = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.topP = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.topK = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxNewTokens = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.doSample = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamplingParameters {
    return {
      temperature: isSet(object.temperature)
        ? globalThis.Number(object.temperature)
        : 0,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : 0,
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      maxNewTokens: isSet(object.maxNewTokens)
        ? globalThis.Number(object.maxNewTokens)
        : 0,
      doSample: isSet(object.doSample)
        ? globalThis.Boolean(object.doSample)
        : false,
    };
  },

  toJSON(message: SamplingParameters): unknown {
    const obj: any = {};
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== 0) {
      obj.topP = message.topP;
    }
    if (message.topK !== undefined) {
      obj.topK = message.topK;
    }
    if (message.maxNewTokens !== 0) {
      obj.maxNewTokens = Math.round(message.maxNewTokens);
    }
    if (message.doSample !== false) {
      obj.doSample = message.doSample;
    }
    return obj;
  },

  create(base?: DeepPartial<SamplingParameters>): SamplingParameters {
    return SamplingParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SamplingParameters>): SamplingParameters {
    const message = createBaseSamplingParameters();
    message.temperature = object.temperature ?? 0;
    message.topP = object.topP ?? 0;
    message.topK = object.topK ?? undefined;
    message.maxNewTokens = object.maxNewTokens ?? 0;
    message.doSample = object.doSample ?? false;
    return message;
  },
};

function createBaseChatCompletionResponse(): ChatCompletionResponse {
  return {
    id: "",
    choices: [],
    created: 0,
    model: "",
    object: "",
    serviceTier: "",
    systemFingerprint: "",
    usage: undefined,
  };
}

export const ChatCompletionResponse: MessageFns<ChatCompletionResponse> = {
  encode(
    message: ChatCompletionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.choices) {
      Choice.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.created !== 0) {
      writer.uint32(24).int64(message.created);
    }
    if (message.model !== "") {
      writer.uint32(34).string(message.model);
    }
    if (message.object !== "") {
      writer.uint32(42).string(message.object);
    }
    if (message.serviceTier !== "") {
      writer.uint32(50).string(message.serviceTier);
    }
    if (message.systemFingerprint !== "") {
      writer.uint32(58).string(message.systemFingerprint);
    }
    if (message.usage !== undefined) {
      CompletionUsage.encode(message.usage, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.choices.push(Choice.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.created = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.object = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.serviceTier = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.systemFingerprint = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.usage = CompletionUsage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => Choice.fromJSON(e))
        : [],
      created: isSet(object.created) ? globalThis.Number(object.created) : 0,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      serviceTier: isSet(object.serviceTier)
        ? globalThis.String(object.serviceTier)
        : "",
      systemFingerprint: isSet(object.systemFingerprint)
        ? globalThis.String(object.systemFingerprint)
        : "",
      usage: isSet(object.usage)
        ? CompletionUsage.fromJSON(object.usage)
        : undefined,
    };
  },

  toJSON(message: ChatCompletionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map(e => Choice.toJSON(e));
    }
    if (message.created !== 0) {
      obj.created = Math.round(message.created);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (message.serviceTier !== "") {
      obj.serviceTier = message.serviceTier;
    }
    if (message.systemFingerprint !== "") {
      obj.systemFingerprint = message.systemFingerprint;
    }
    if (message.usage !== undefined) {
      obj.usage = CompletionUsage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionResponse>): ChatCompletionResponse {
    return ChatCompletionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChatCompletionResponse>,
  ): ChatCompletionResponse {
    const message = createBaseChatCompletionResponse();
    message.id = object.id ?? "";
    message.choices = object.choices?.map(e => Choice.fromPartial(e)) || [];
    message.created = object.created ?? 0;
    message.model = object.model ?? "";
    message.object = object.object ?? "";
    message.serviceTier = object.serviceTier ?? "";
    message.systemFingerprint = object.systemFingerprint ?? "";
    message.usage =
      object.usage !== undefined && object.usage !== null
        ? CompletionUsage.fromPartial(object.usage)
        : undefined;
    return message;
  },
};

function createBaseChoice(): Choice {
  return {
    finishReason: "",
    index: 0,
    logprobs: undefined,
    message: undefined,
  };
}

export const Choice: MessageFns<Choice> = {
  encode(
    message: Choice,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.finishReason !== "") {
      writer.uint32(10).string(message.finishReason);
    }
    if (message.index !== 0) {
      writer.uint32(16).int64(message.index);
    }
    if (message.logprobs !== undefined) {
      ChoiceLogprobs.encode(message.logprobs, writer.uint32(26).fork()).join();
    }
    if (message.message !== undefined) {
      ChatCompletionMessage.encode(
        message.message,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Choice {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logprobs = ChoiceLogprobs.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = ChatCompletionMessage.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Choice {
    return {
      finishReason: isSet(object.finishReason)
        ? globalThis.String(object.finishReason)
        : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      logprobs: isSet(object.logprobs)
        ? ChoiceLogprobs.fromJSON(object.logprobs)
        : undefined,
      message: isSet(object.message)
        ? ChatCompletionMessage.fromJSON(object.message)
        : undefined,
    };
  },

  toJSON(message: Choice): unknown {
    const obj: any = {};
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.logprobs !== undefined) {
      obj.logprobs = ChoiceLogprobs.toJSON(message.logprobs);
    }
    if (message.message !== undefined) {
      obj.message = ChatCompletionMessage.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<Choice>): Choice {
    return Choice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Choice>): Choice {
    const message = createBaseChoice();
    message.finishReason = object.finishReason ?? "";
    message.index = object.index ?? 0;
    message.logprobs =
      object.logprobs !== undefined && object.logprobs !== null
        ? ChoiceLogprobs.fromPartial(object.logprobs)
        : undefined;
    message.message =
      object.message !== undefined && object.message !== null
        ? ChatCompletionMessage.fromPartial(object.message)
        : undefined;
    return message;
  },
};

function createBaseChatCompletionMessage(): ChatCompletionMessage {
  return {
    content: "",
    refusal: "",
    role: "",
    annotations: [],
    audio: undefined,
    functionCall: undefined,
    toolCalls: [],
  };
}

export const ChatCompletionMessage: MessageFns<ChatCompletionMessage> = {
  encode(
    message: ChatCompletionMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.refusal !== "") {
      writer.uint32(18).string(message.refusal);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.audio !== undefined) {
      ChatCompletionAudio.encode(
        message.audio,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.functionCall !== undefined) {
      FunctionCall.encode(
        message.functionCall,
        writer.uint32(50).fork(),
      ).join();
    }
    for (const v of message.toolCalls) {
      ChatCompletionMessageToolCall.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refusal = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.audio = ChatCompletionAudio.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.functionCall = FunctionCall.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toolCalls.push(
            ChatCompletionMessageToolCall.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionMessage {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      refusal: isSet(object.refusal) ? globalThis.String(object.refusal) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      audio: isSet(object.audio)
        ? ChatCompletionAudio.fromJSON(object.audio)
        : undefined,
      functionCall: isSet(object.functionCall)
        ? FunctionCall.fromJSON(object.functionCall)
        : undefined,
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) =>
            ChatCompletionMessageToolCall.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: ChatCompletionMessage): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.refusal !== "") {
      obj.refusal = message.refusal;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map(e => Annotation.toJSON(e));
    }
    if (message.audio !== undefined) {
      obj.audio = ChatCompletionAudio.toJSON(message.audio);
    }
    if (message.functionCall !== undefined) {
      obj.functionCall = FunctionCall.toJSON(message.functionCall);
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map(e =>
        ChatCompletionMessageToolCall.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionMessage>): ChatCompletionMessage {
    return ChatCompletionMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChatCompletionMessage>,
  ): ChatCompletionMessage {
    const message = createBaseChatCompletionMessage();
    message.content = object.content ?? "";
    message.refusal = object.refusal ?? "";
    message.role = object.role ?? "";
    message.annotations =
      object.annotations?.map(e => Annotation.fromPartial(e)) || [];
    message.audio =
      object.audio !== undefined && object.audio !== null
        ? ChatCompletionAudio.fromPartial(object.audio)
        : undefined;
    message.functionCall =
      object.functionCall !== undefined && object.functionCall !== null
        ? FunctionCall.fromPartial(object.functionCall)
        : undefined;
    message.toolCalls =
      object.toolCalls?.map(e =>
        ChatCompletionMessageToolCall.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { content: "", role: "" };
}

export const Annotation: MessageFns<Annotation> = {
  encode(
    message: Annotation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.content = object.content ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseChatCompletionAudio(): ChatCompletionAudio {
  return { id: "", data: "", expiresAt: 0, transcript: "" };
}

export const ChatCompletionAudio: MessageFns<ChatCompletionAudio> = {
  encode(
    message: ChatCompletionAudio,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(24).int64(message.expiresAt);
    }
    if (message.transcript !== "") {
      writer.uint32(34).string(message.transcript);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChatCompletionAudio {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transcript = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionAudio {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      expiresAt: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : 0,
      transcript: isSet(object.transcript)
        ? globalThis.String(object.transcript)
        : "",
    };
  },

  toJSON(message: ChatCompletionAudio): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    if (message.transcript !== "") {
      obj.transcript = message.transcript;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatCompletionAudio>): ChatCompletionAudio {
    return ChatCompletionAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatCompletionAudio>): ChatCompletionAudio {
    const message = createBaseChatCompletionAudio();
    message.id = object.id ?? "";
    message.data = object.data ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    message.transcript = object.transcript ?? "";
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { arguments: [], name: "" };
}

export const FunctionCall: MessageFns<FunctionCall> = {
  encode(
    message: FunctionCall,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCall {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCall>): FunctionCall {
    return FunctionCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCall>): FunctionCall {
    const message = createBaseFunctionCall();
    message.arguments = object.arguments?.map(e => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChatCompletionMessageToolCall(): ChatCompletionMessageToolCall {
  return { id: "", function: undefined, type: "" };
}

export const ChatCompletionMessageToolCall: MessageFns<ChatCompletionMessageToolCall> =
  {
    encode(
      message: ChatCompletionMessageToolCall,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.id !== "") {
        writer.uint32(10).string(message.id);
      }
      if (message.function !== undefined) {
        FunctionMessage.encode(
          message.function,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.type !== "") {
        writer.uint32(26).string(message.type);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChatCompletionMessageToolCall {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChatCompletionMessageToolCall();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.id = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.function = FunctionMessage.decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.type = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChatCompletionMessageToolCall {
      return {
        id: isSet(object.id) ? globalThis.String(object.id) : "",
        function: isSet(object.function)
          ? FunctionMessage.fromJSON(object.function)
          : undefined,
        type: isSet(object.type) ? globalThis.String(object.type) : "",
      };
    },

    toJSON(message: ChatCompletionMessageToolCall): unknown {
      const obj: any = {};
      if (message.id !== "") {
        obj.id = message.id;
      }
      if (message.function !== undefined) {
        obj.function = FunctionMessage.toJSON(message.function);
      }
      if (message.type !== "") {
        obj.type = message.type;
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChatCompletionMessageToolCall>,
    ): ChatCompletionMessageToolCall {
      return ChatCompletionMessageToolCall.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChatCompletionMessageToolCall>,
    ): ChatCompletionMessageToolCall {
      const message = createBaseChatCompletionMessageToolCall();
      message.id = object.id ?? "";
      message.function =
        object.function !== undefined && object.function !== null
          ? FunctionMessage.fromPartial(object.function)
          : undefined;
      message.type = object.type ?? "";
      return message;
    },
  };

function createBaseFunctionMessage(): FunctionMessage {
  return { arguments: [], name: "" };
}

export const FunctionMessage: MessageFns<FunctionMessage> = {
  encode(
    message: FunctionMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionMessage {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FunctionMessage): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionMessage>): FunctionMessage {
    return FunctionMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionMessage>): FunctionMessage {
    const message = createBaseFunctionMessage();
    message.arguments = object.arguments?.map(e => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChatCompletionChunkResponse(): ChatCompletionChunkResponse {
  return {
    id: "",
    choices: [],
    created: 0,
    model: "",
    object: "",
    serviceTier: "",
    systemFingerprint: "",
    usage: undefined,
  };
}

export const ChatCompletionChunkResponse: MessageFns<ChatCompletionChunkResponse> =
  {
    encode(
      message: ChatCompletionChunkResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.id !== "") {
        writer.uint32(10).string(message.id);
      }
      for (const v of message.choices) {
        ChunkChoice.encode(v!, writer.uint32(18).fork()).join();
      }
      if (message.created !== 0) {
        writer.uint32(24).int64(message.created);
      }
      if (message.model !== "") {
        writer.uint32(34).string(message.model);
      }
      if (message.object !== "") {
        writer.uint32(42).string(message.object);
      }
      if (message.serviceTier !== "") {
        writer.uint32(50).string(message.serviceTier);
      }
      if (message.systemFingerprint !== "") {
        writer.uint32(58).string(message.systemFingerprint);
      }
      if (message.usage !== undefined) {
        CompletionUsage.encode(message.usage, writer.uint32(66).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChatCompletionChunkResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChatCompletionChunkResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.id = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.choices.push(ChunkChoice.decode(reader, reader.uint32()));
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.created = longToNumber(reader.int64());
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.model = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.object = reader.string();
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.serviceTier = reader.string();
            continue;
          }
          case 7: {
            if (tag !== 58) {
              break;
            }

            message.systemFingerprint = reader.string();
            continue;
          }
          case 8: {
            if (tag !== 66) {
              break;
            }

            message.usage = CompletionUsage.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChatCompletionChunkResponse {
      return {
        id: isSet(object.id) ? globalThis.String(object.id) : "",
        choices: globalThis.Array.isArray(object?.choices)
          ? object.choices.map((e: any) => ChunkChoice.fromJSON(e))
          : [],
        created: isSet(object.created) ? globalThis.Number(object.created) : 0,
        model: isSet(object.model) ? globalThis.String(object.model) : "",
        object: isSet(object.object) ? globalThis.String(object.object) : "",
        serviceTier: isSet(object.serviceTier)
          ? globalThis.String(object.serviceTier)
          : "",
        systemFingerprint: isSet(object.systemFingerprint)
          ? globalThis.String(object.systemFingerprint)
          : "",
        usage: isSet(object.usage)
          ? CompletionUsage.fromJSON(object.usage)
          : undefined,
      };
    },

    toJSON(message: ChatCompletionChunkResponse): unknown {
      const obj: any = {};
      if (message.id !== "") {
        obj.id = message.id;
      }
      if (message.choices?.length) {
        obj.choices = message.choices.map(e => ChunkChoice.toJSON(e));
      }
      if (message.created !== 0) {
        obj.created = Math.round(message.created);
      }
      if (message.model !== "") {
        obj.model = message.model;
      }
      if (message.object !== "") {
        obj.object = message.object;
      }
      if (message.serviceTier !== "") {
        obj.serviceTier = message.serviceTier;
      }
      if (message.systemFingerprint !== "") {
        obj.systemFingerprint = message.systemFingerprint;
      }
      if (message.usage !== undefined) {
        obj.usage = CompletionUsage.toJSON(message.usage);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChatCompletionChunkResponse>,
    ): ChatCompletionChunkResponse {
      return ChatCompletionChunkResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChatCompletionChunkResponse>,
    ): ChatCompletionChunkResponse {
      const message = createBaseChatCompletionChunkResponse();
      message.id = object.id ?? "";
      message.choices =
        object.choices?.map(e => ChunkChoice.fromPartial(e)) || [];
      message.created = object.created ?? 0;
      message.model = object.model ?? "";
      message.object = object.object ?? "";
      message.serviceTier = object.serviceTier ?? "";
      message.systemFingerprint = object.systemFingerprint ?? "";
      message.usage =
        object.usage !== undefined && object.usage !== null
          ? CompletionUsage.fromPartial(object.usage)
          : undefined;
      return message;
    },
  };

function createBaseChatMessage(): ChatMessage {
  return { role: "", content: "" };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(
    message: ChatMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<ChatMessage>): ChatMessage {
    return ChatMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatMessage>): ChatMessage {
    const message = createBaseChatMessage();
    message.role = object.role ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseChunkChoice(): ChunkChoice {
  return { delta: undefined, finishReason: "", index: 0, logprobs: undefined };
}

export const ChunkChoice: MessageFns<ChunkChoice> = {
  encode(
    message: ChunkChoice,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.delta !== undefined) {
      ChoiceDelta.encode(message.delta, writer.uint32(10).fork()).join();
    }
    if (message.finishReason !== "") {
      writer.uint32(18).string(message.finishReason);
    }
    if (message.index !== 0) {
      writer.uint32(24).int64(message.index);
    }
    if (message.logprobs !== undefined) {
      ChoiceLogprobs.encode(message.logprobs, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkChoice {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delta = ChoiceDelta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logprobs = ChoiceLogprobs.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkChoice {
    return {
      delta: isSet(object.delta)
        ? ChoiceDelta.fromJSON(object.delta)
        : undefined,
      finishReason: isSet(object.finishReason)
        ? globalThis.String(object.finishReason)
        : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      logprobs: isSet(object.logprobs)
        ? ChoiceLogprobs.fromJSON(object.logprobs)
        : undefined,
    };
  },

  toJSON(message: ChunkChoice): unknown {
    const obj: any = {};
    if (message.delta !== undefined) {
      obj.delta = ChoiceDelta.toJSON(message.delta);
    }
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.logprobs !== undefined) {
      obj.logprobs = ChoiceLogprobs.toJSON(message.logprobs);
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkChoice>): ChunkChoice {
    return ChunkChoice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkChoice>): ChunkChoice {
    const message = createBaseChunkChoice();
    message.delta =
      object.delta !== undefined && object.delta !== null
        ? ChoiceDelta.fromPartial(object.delta)
        : undefined;
    message.finishReason = object.finishReason ?? "";
    message.index = object.index ?? 0;
    message.logprobs =
      object.logprobs !== undefined && object.logprobs !== null
        ? ChoiceLogprobs.fromPartial(object.logprobs)
        : undefined;
    return message;
  },
};

function createBaseChoiceLogprobs(): ChoiceLogprobs {
  return { content: [], refusal: [] };
}

export const ChoiceLogprobs: MessageFns<ChoiceLogprobs> = {
  encode(
    message: ChoiceLogprobs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.content) {
      ChatCompletionTokenLogprob.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.refusal) {
      ChatCompletionTokenLogprob.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChoiceLogprobs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceLogprobs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content.push(
            ChatCompletionTokenLogprob.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refusal.push(
            ChatCompletionTokenLogprob.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceLogprobs {
    return {
      content: globalThis.Array.isArray(object?.content)
        ? object.content.map((e: any) => ChatCompletionTokenLogprob.fromJSON(e))
        : [],
      refusal: globalThis.Array.isArray(object?.refusal)
        ? object.refusal.map((e: any) => ChatCompletionTokenLogprob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChoiceLogprobs): unknown {
    const obj: any = {};
    if (message.content?.length) {
      obj.content = message.content.map(e =>
        ChatCompletionTokenLogprob.toJSON(e),
      );
    }
    if (message.refusal?.length) {
      obj.refusal = message.refusal.map(e =>
        ChatCompletionTokenLogprob.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceLogprobs>): ChoiceLogprobs {
    return ChoiceLogprobs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChoiceLogprobs>): ChoiceLogprobs {
    const message = createBaseChoiceLogprobs();
    message.content =
      object.content?.map(e => ChatCompletionTokenLogprob.fromPartial(e)) || [];
    message.refusal =
      object.refusal?.map(e => ChatCompletionTokenLogprob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChoiceDelta(): ChoiceDelta {
  return {
    content: "",
    functionCall: undefined,
    refusal: "",
    role: "",
    toolCalls: [],
  };
}

export const ChoiceDelta: MessageFns<ChoiceDelta> = {
  encode(
    message: ChoiceDelta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.functionCall !== undefined) {
      ChoiceDeltaFunctionCall.encode(
        message.functionCall,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.refusal !== "") {
      writer.uint32(26).string(message.refusal);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    for (const v of message.toolCalls) {
      ChoiceDeltaToolCall.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChoiceDelta {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.functionCall = ChoiceDeltaFunctionCall.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refusal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolCalls.push(
            ChoiceDeltaToolCall.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceDelta {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      functionCall: isSet(object.functionCall)
        ? ChoiceDeltaFunctionCall.fromJSON(object.functionCall)
        : undefined,
      refusal: isSet(object.refusal) ? globalThis.String(object.refusal) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ChoiceDeltaToolCall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChoiceDelta): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.functionCall !== undefined) {
      obj.functionCall = ChoiceDeltaFunctionCall.toJSON(message.functionCall);
    }
    if (message.refusal !== "") {
      obj.refusal = message.refusal;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map(e => ChoiceDeltaToolCall.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceDelta>): ChoiceDelta {
    return ChoiceDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChoiceDelta>): ChoiceDelta {
    const message = createBaseChoiceDelta();
    message.content = object.content ?? "";
    message.functionCall =
      object.functionCall !== undefined && object.functionCall !== null
        ? ChoiceDeltaFunctionCall.fromPartial(object.functionCall)
        : undefined;
    message.refusal = object.refusal ?? "";
    message.role = object.role ?? "";
    message.toolCalls =
      object.toolCalls?.map(e => ChoiceDeltaToolCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChoiceDeltaFunctionCall(): ChoiceDeltaFunctionCall {
  return { arguments: [], name: "" };
}

export const ChoiceDeltaFunctionCall: MessageFns<ChoiceDeltaFunctionCall> = {
  encode(
    message: ChoiceDeltaFunctionCall,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChoiceDeltaFunctionCall {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceDeltaFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceDeltaFunctionCall {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ChoiceDeltaFunctionCall): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceDeltaFunctionCall>): ChoiceDeltaFunctionCall {
    return ChoiceDeltaFunctionCall.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ChoiceDeltaFunctionCall>,
  ): ChoiceDeltaFunctionCall {
    const message = createBaseChoiceDeltaFunctionCall();
    message.arguments = object.arguments?.map(e => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseChoiceDeltaToolCall(): ChoiceDeltaToolCall {
  return { index: 0, id: "", function: undefined, type: "" };
}

export const ChoiceDeltaToolCall: MessageFns<ChoiceDeltaToolCall> = {
  encode(
    message: ChoiceDeltaToolCall,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int64(message.index);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.function !== undefined) {
      ChoiceDeltaToolCallFunction.encode(
        message.function,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChoiceDeltaToolCall {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChoiceDeltaToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.function = ChoiceDeltaToolCallFunction.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChoiceDeltaToolCall {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      function: isSet(object.function)
        ? ChoiceDeltaToolCallFunction.fromJSON(object.function)
        : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: ChoiceDeltaToolCall): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.function !== undefined) {
      obj.function = ChoiceDeltaToolCallFunction.toJSON(message.function);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<ChoiceDeltaToolCall>): ChoiceDeltaToolCall {
    return ChoiceDeltaToolCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChoiceDeltaToolCall>): ChoiceDeltaToolCall {
    const message = createBaseChoiceDeltaToolCall();
    message.index = object.index ?? 0;
    message.id = object.id ?? "";
    message.function =
      object.function !== undefined && object.function !== null
        ? ChoiceDeltaToolCallFunction.fromPartial(object.function)
        : undefined;
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseChoiceDeltaToolCallFunction(): ChoiceDeltaToolCallFunction {
  return { arguments: [], name: "" };
}

export const ChoiceDeltaToolCallFunction: MessageFns<ChoiceDeltaToolCallFunction> =
  {
    encode(
      message: ChoiceDeltaToolCallFunction,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.arguments) {
        writer.uint32(10).string(v!);
      }
      if (message.name !== "") {
        writer.uint32(18).string(message.name);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChoiceDeltaToolCallFunction {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChoiceDeltaToolCallFunction();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.arguments.push(reader.string());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.name = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChoiceDeltaToolCallFunction {
      return {
        arguments: globalThis.Array.isArray(object?.arguments)
          ? object.arguments.map((e: any) => globalThis.String(e))
          : [],
        name: isSet(object.name) ? globalThis.String(object.name) : "",
      };
    },

    toJSON(message: ChoiceDeltaToolCallFunction): unknown {
      const obj: any = {};
      if (message.arguments?.length) {
        obj.arguments = message.arguments;
      }
      if (message.name !== "") {
        obj.name = message.name;
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChoiceDeltaToolCallFunction>,
    ): ChoiceDeltaToolCallFunction {
      return ChoiceDeltaToolCallFunction.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChoiceDeltaToolCallFunction>,
    ): ChoiceDeltaToolCallFunction {
      const message = createBaseChoiceDeltaToolCallFunction();
      message.arguments = object.arguments?.map(e => e) || [];
      message.name = object.name ?? "";
      return message;
    },
  };

function createBaseChatCompletionTokenLogprob(): ChatCompletionTokenLogprob {
  return { token: "", bytes: [], logprob: 0, topLogprobs: [] };
}

export const ChatCompletionTokenLogprob: MessageFns<ChatCompletionTokenLogprob> =
  {
    encode(
      message: ChatCompletionTokenLogprob,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.token !== "") {
        writer.uint32(10).string(message.token);
      }
      writer.uint32(18).fork();
      for (const v of message.bytes) {
        writer.int64(v);
      }
      writer.join();
      if (message.logprob !== 0) {
        writer.uint32(25).double(message.logprob);
      }
      for (const v of message.topLogprobs) {
        TopLogprob.encode(v!, writer.uint32(34).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChatCompletionTokenLogprob {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChatCompletionTokenLogprob();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.token = reader.string();
            continue;
          }
          case 2: {
            if (tag === 16) {
              message.bytes.push(longToNumber(reader.int64()));

              continue;
            }

            if (tag === 18) {
              const end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {
                message.bytes.push(longToNumber(reader.int64()));
              }

              continue;
            }

            break;
          }
          case 3: {
            if (tag !== 25) {
              break;
            }

            message.logprob = reader.double();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.topLogprobs.push(
              TopLogprob.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChatCompletionTokenLogprob {
      return {
        token: isSet(object.token) ? globalThis.String(object.token) : "",
        bytes: globalThis.Array.isArray(object?.bytes)
          ? object.bytes.map((e: any) => globalThis.Number(e))
          : [],
        logprob: isSet(object.logprob) ? globalThis.Number(object.logprob) : 0,
        topLogprobs: globalThis.Array.isArray(object?.topLogprobs)
          ? object.topLogprobs.map((e: any) => TopLogprob.fromJSON(e))
          : [],
      };
    },

    toJSON(message: ChatCompletionTokenLogprob): unknown {
      const obj: any = {};
      if (message.token !== "") {
        obj.token = message.token;
      }
      if (message.bytes?.length) {
        obj.bytes = message.bytes.map(e => Math.round(e));
      }
      if (message.logprob !== 0) {
        obj.logprob = message.logprob;
      }
      if (message.topLogprobs?.length) {
        obj.topLogprobs = message.topLogprobs.map(e => TopLogprob.toJSON(e));
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChatCompletionTokenLogprob>,
    ): ChatCompletionTokenLogprob {
      return ChatCompletionTokenLogprob.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChatCompletionTokenLogprob>,
    ): ChatCompletionTokenLogprob {
      const message = createBaseChatCompletionTokenLogprob();
      message.token = object.token ?? "";
      message.bytes = object.bytes?.map(e => e) || [];
      message.logprob = object.logprob ?? 0;
      message.topLogprobs =
        object.topLogprobs?.map(e => TopLogprob.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseTopLogprob(): TopLogprob {
  return { token: "", bytes: [], logprob: 0 };
}

export const TopLogprob: MessageFns<TopLogprob> = {
  encode(
    message: TopLogprob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    writer.uint32(18).fork();
    for (const v of message.bytes) {
      writer.int64(v);
    }
    writer.join();
    if (message.logprob !== 0) {
      writer.uint32(25).double(message.logprob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopLogprob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopLogprob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.bytes.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bytes.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.logprob = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopLogprob {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      bytes: globalThis.Array.isArray(object?.bytes)
        ? object.bytes.map((e: any) => globalThis.Number(e))
        : [],
      logprob: isSet(object.logprob) ? globalThis.Number(object.logprob) : 0,
    };
  },

  toJSON(message: TopLogprob): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.bytes?.length) {
      obj.bytes = message.bytes.map(e => Math.round(e));
    }
    if (message.logprob !== 0) {
      obj.logprob = message.logprob;
    }
    return obj;
  },

  create(base?: DeepPartial<TopLogprob>): TopLogprob {
    return TopLogprob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopLogprob>): TopLogprob {
    const message = createBaseTopLogprob();
    message.token = object.token ?? "";
    message.bytes = object.bytes?.map(e => e) || [];
    message.logprob = object.logprob ?? 0;
    return message;
  },
};

function createBaseCompletionUsage(): CompletionUsage {
  return {
    completionTokens: 0,
    promptTokens: 0,
    totalTokens: 0,
    completionTokensDetails: undefined,
    promptTokensDetails: undefined,
  };
}

export const CompletionUsage: MessageFns<CompletionUsage> = {
  encode(
    message: CompletionUsage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.completionTokens !== 0) {
      writer.uint32(8).int64(message.completionTokens);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(16).int64(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int64(message.totalTokens);
    }
    if (message.completionTokensDetails !== undefined) {
      CompletionTokensDetails.encode(
        message.completionTokensDetails,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.promptTokensDetails !== undefined) {
      PromptTokensDetails.encode(
        message.promptTokensDetails,
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletionUsage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.completionTokensDetails = CompletionTokensDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.promptTokensDetails = PromptTokensDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionUsage {
    return {
      completionTokens: isSet(object.completionTokens)
        ? globalThis.Number(object.completionTokens)
        : 0,
      promptTokens: isSet(object.promptTokens)
        ? globalThis.Number(object.promptTokens)
        : 0,
      totalTokens: isSet(object.totalTokens)
        ? globalThis.Number(object.totalTokens)
        : 0,
      completionTokensDetails: isSet(object.completionTokensDetails)
        ? CompletionTokensDetails.fromJSON(object.completionTokensDetails)
        : undefined,
      promptTokensDetails: isSet(object.promptTokensDetails)
        ? PromptTokensDetails.fromJSON(object.promptTokensDetails)
        : undefined,
    };
  },

  toJSON(message: CompletionUsage): unknown {
    const obj: any = {};
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.completionTokensDetails !== undefined) {
      obj.completionTokensDetails = CompletionTokensDetails.toJSON(
        message.completionTokensDetails,
      );
    }
    if (message.promptTokensDetails !== undefined) {
      obj.promptTokensDetails = PromptTokensDetails.toJSON(
        message.promptTokensDetails,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionUsage>): CompletionUsage {
    return CompletionUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompletionUsage>): CompletionUsage {
    const message = createBaseCompletionUsage();
    message.completionTokens = object.completionTokens ?? 0;
    message.promptTokens = object.promptTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.completionTokensDetails =
      object.completionTokensDetails !== undefined &&
      object.completionTokensDetails !== null
        ? CompletionTokensDetails.fromPartial(object.completionTokensDetails)
        : undefined;
    message.promptTokensDetails =
      object.promptTokensDetails !== undefined &&
      object.promptTokensDetails !== null
        ? PromptTokensDetails.fromPartial(object.promptTokensDetails)
        : undefined;
    return message;
  },
};

function createBaseCompletionTokensDetails(): CompletionTokensDetails {
  return {
    acceptedPredictionTokens: 0,
    audioTokens: 0,
    reasoningTokens: 0,
    rejectedPredictionTokens: 0,
  };
}

export const CompletionTokensDetails: MessageFns<CompletionTokensDetails> = {
  encode(
    message: CompletionTokensDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.acceptedPredictionTokens !== 0) {
      writer.uint32(8).int64(message.acceptedPredictionTokens);
    }
    if (message.audioTokens !== 0) {
      writer.uint32(16).int64(message.audioTokens);
    }
    if (message.reasoningTokens !== 0) {
      writer.uint32(24).int64(message.reasoningTokens);
    }
    if (message.rejectedPredictionTokens !== 0) {
      writer.uint32(32).int64(message.rejectedPredictionTokens);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CompletionTokensDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionTokensDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.acceptedPredictionTokens = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.audioTokens = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reasoningTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rejectedPredictionTokens = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionTokensDetails {
    return {
      acceptedPredictionTokens: isSet(object.acceptedPredictionTokens)
        ? globalThis.Number(object.acceptedPredictionTokens)
        : 0,
      audioTokens: isSet(object.audioTokens)
        ? globalThis.Number(object.audioTokens)
        : 0,
      reasoningTokens: isSet(object.reasoningTokens)
        ? globalThis.Number(object.reasoningTokens)
        : 0,
      rejectedPredictionTokens: isSet(object.rejectedPredictionTokens)
        ? globalThis.Number(object.rejectedPredictionTokens)
        : 0,
    };
  },

  toJSON(message: CompletionTokensDetails): unknown {
    const obj: any = {};
    if (message.acceptedPredictionTokens !== 0) {
      obj.acceptedPredictionTokens = Math.round(
        message.acceptedPredictionTokens,
      );
    }
    if (message.audioTokens !== 0) {
      obj.audioTokens = Math.round(message.audioTokens);
    }
    if (message.reasoningTokens !== 0) {
      obj.reasoningTokens = Math.round(message.reasoningTokens);
    }
    if (message.rejectedPredictionTokens !== 0) {
      obj.rejectedPredictionTokens = Math.round(
        message.rejectedPredictionTokens,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionTokensDetails>): CompletionTokensDetails {
    return CompletionTokensDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CompletionTokensDetails>,
  ): CompletionTokensDetails {
    const message = createBaseCompletionTokensDetails();
    message.acceptedPredictionTokens = object.acceptedPredictionTokens ?? 0;
    message.audioTokens = object.audioTokens ?? 0;
    message.reasoningTokens = object.reasoningTokens ?? 0;
    message.rejectedPredictionTokens = object.rejectedPredictionTokens ?? 0;
    return message;
  },
};

function createBasePromptTokensDetails(): PromptTokensDetails {
  return { audioTokens: 0, cachedTokens: 0 };
}

export const PromptTokensDetails: MessageFns<PromptTokensDetails> = {
  encode(
    message: PromptTokensDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.audioTokens !== 0) {
      writer.uint32(8).int64(message.audioTokens);
    }
    if (message.cachedTokens !== 0) {
      writer.uint32(16).int64(message.cachedTokens);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PromptTokensDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptTokensDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioTokens = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cachedTokens = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptTokensDetails {
    return {
      audioTokens: isSet(object.audioTokens)
        ? globalThis.Number(object.audioTokens)
        : 0,
      cachedTokens: isSet(object.cachedTokens)
        ? globalThis.Number(object.cachedTokens)
        : 0,
    };
  },

  toJSON(message: PromptTokensDetails): unknown {
    const obj: any = {};
    if (message.audioTokens !== 0) {
      obj.audioTokens = Math.round(message.audioTokens);
    }
    if (message.cachedTokens !== 0) {
      obj.cachedTokens = Math.round(message.cachedTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<PromptTokensDetails>): PromptTokensDetails {
    return PromptTokensDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PromptTokensDetails>): PromptTokensDetails {
    const message = createBasePromptTokensDetails();
    message.audioTokens = object.audioTokens ?? 0;
    message.cachedTokens = object.cachedTokens ?? 0;
    return message;
  },
};

function createBaseWebRetrievalRequest(): WebRetrievalRequest {
  return {
    uids: [],
    searchQuery: "",
    nMiners: undefined,
    nResults: undefined,
    maxResponseTime: undefined,
    timeout: undefined,
  };
}

export const WebRetrievalRequest: MessageFns<WebRetrievalRequest> = {
  encode(
    message: WebRetrievalRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.uids) {
      writer.int64(v);
    }
    writer.join();
    if (message.searchQuery !== "") {
      writer.uint32(18).string(message.searchQuery);
    }
    if (message.nMiners !== undefined) {
      writer.uint32(24).int64(message.nMiners);
    }
    if (message.nResults !== undefined) {
      writer.uint32(32).int64(message.nResults);
    }
    if (message.maxResponseTime !== undefined) {
      writer.uint32(40).int64(message.maxResponseTime);
    }
    if (message.timeout !== undefined) {
      writer.uint32(48).int64(message.timeout);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebRetrievalRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebRetrievalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.uids.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uids.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nMiners = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nResults = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxResponseTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timeout = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebRetrievalRequest {
    return {
      uids: globalThis.Array.isArray(object?.uids)
        ? object.uids.map((e: any) => globalThis.Number(e))
        : [],
      searchQuery: isSet(object.searchQuery)
        ? globalThis.String(object.searchQuery)
        : "",
      nMiners: isSet(object.nMiners)
        ? globalThis.Number(object.nMiners)
        : undefined,
      nResults: isSet(object.nResults)
        ? globalThis.Number(object.nResults)
        : undefined,
      maxResponseTime: isSet(object.maxResponseTime)
        ? globalThis.Number(object.maxResponseTime)
        : undefined,
      timeout: isSet(object.timeout)
        ? globalThis.Number(object.timeout)
        : undefined,
    };
  },

  toJSON(message: WebRetrievalRequest): unknown {
    const obj: any = {};
    if (message.uids?.length) {
      obj.uids = message.uids.map(e => Math.round(e));
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.nMiners !== undefined) {
      obj.nMiners = Math.round(message.nMiners);
    }
    if (message.nResults !== undefined) {
      obj.nResults = Math.round(message.nResults);
    }
    if (message.maxResponseTime !== undefined) {
      obj.maxResponseTime = Math.round(message.maxResponseTime);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Math.round(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<WebRetrievalRequest>): WebRetrievalRequest {
    return WebRetrievalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebRetrievalRequest>): WebRetrievalRequest {
    const message = createBaseWebRetrievalRequest();
    message.uids = object.uids?.map(e => e) || [];
    message.searchQuery = object.searchQuery ?? "";
    message.nMiners = object.nMiners ?? undefined;
    message.nResults = object.nResults ?? undefined;
    message.maxResponseTime = object.maxResponseTime ?? undefined;
    message.timeout = object.timeout ?? undefined;
    return message;
  },
};

function createBaseWebSearchResult(): WebSearchResult {
  return { url: "", content: "", relevant: "" };
}

export const WebSearchResult: MessageFns<WebSearchResult> = {
  encode(
    message: WebSearchResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.relevant !== "") {
      writer.uint32(26).string(message.relevant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebSearchResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relevant = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebSearchResult {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      relevant: isSet(object.relevant)
        ? globalThis.String(object.relevant)
        : "",
    };
  },

  toJSON(message: WebSearchResult): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.relevant !== "") {
      obj.relevant = message.relevant;
    }
    return obj;
  },

  create(base?: DeepPartial<WebSearchResult>): WebSearchResult {
    return WebSearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebSearchResult>): WebSearchResult {
    const message = createBaseWebSearchResult();
    message.url = object.url ?? "";
    message.content = object.content ?? "";
    message.relevant = object.relevant ?? "";
    return message;
  },
};

function createBaseWebRetrievalResponse(): WebRetrievalResponse {
  return { results: [] };
}

export const WebRetrievalResponse: MessageFns<WebRetrievalResponse> = {
  encode(
    message: WebRetrievalResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.results) {
      WebSearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebRetrievalResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebRetrievalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(WebSearchResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebRetrievalResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => WebSearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebRetrievalResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map(e => WebSearchResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebRetrievalResponse>): WebRetrievalResponse {
    return WebRetrievalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebRetrievalResponse>): WebRetrievalResponse {
    const message = createBaseWebRetrievalResponse();
    message.results =
      object.results?.map(e => WebSearchResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmitDeepResearcherJobResponse(): SubmitDeepResearcherJobResponse {
  return { jobId: "", status: "", createdAt: "", updatedAt: "" };
}

export const SubmitDeepResearcherJobResponse: MessageFns<SubmitDeepResearcherJobResponse> =
  {
    encode(
      message: SubmitDeepResearcherJobResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.jobId !== "") {
        writer.uint32(10).string(message.jobId);
      }
      if (message.status !== "") {
        writer.uint32(18).string(message.status);
      }
      if (message.createdAt !== "") {
        writer.uint32(26).string(message.createdAt);
      }
      if (message.updatedAt !== "") {
        writer.uint32(34).string(message.updatedAt);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SubmitDeepResearcherJobResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSubmitDeepResearcherJobResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.jobId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.status = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.createdAt = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.updatedAt = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SubmitDeepResearcherJobResponse {
      return {
        jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
        status: isSet(object.status) ? globalThis.String(object.status) : "",
        createdAt: isSet(object.createdAt)
          ? globalThis.String(object.createdAt)
          : "",
        updatedAt: isSet(object.updatedAt)
          ? globalThis.String(object.updatedAt)
          : "",
      };
    },

    toJSON(message: SubmitDeepResearcherJobResponse): unknown {
      const obj: any = {};
      if (message.jobId !== "") {
        obj.jobId = message.jobId;
      }
      if (message.status !== "") {
        obj.status = message.status;
      }
      if (message.createdAt !== "") {
        obj.createdAt = message.createdAt;
      }
      if (message.updatedAt !== "") {
        obj.updatedAt = message.updatedAt;
      }
      return obj;
    },

    create(
      base?: DeepPartial<SubmitDeepResearcherJobResponse>,
    ): SubmitDeepResearcherJobResponse {
      return SubmitDeepResearcherJobResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SubmitDeepResearcherJobResponse>,
    ): SubmitDeepResearcherJobResponse {
      const message = createBaseSubmitDeepResearcherJobResponse();
      message.jobId = object.jobId ?? "";
      message.status = object.status ?? "";
      message.createdAt = object.createdAt ?? "";
      message.updatedAt = object.updatedAt ?? "";
      return message;
    },
  };

function createBaseGetDeepResearcherJobResponse(): GetDeepResearcherJobResponse {
  return {
    jobId: "",
    status: "",
    createdAt: "",
    updatedAt: "",
    result: [],
    error: undefined,
  };
}

export const GetDeepResearcherJobResponse: MessageFns<GetDeepResearcherJobResponse> =
  {
    encode(
      message: GetDeepResearcherJobResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.jobId !== "") {
        writer.uint32(10).string(message.jobId);
      }
      if (message.status !== "") {
        writer.uint32(18).string(message.status);
      }
      if (message.createdAt !== "") {
        writer.uint32(26).string(message.createdAt);
      }
      if (message.updatedAt !== "") {
        writer.uint32(34).string(message.updatedAt);
      }
      for (const v of message.result) {
        DeepResearcherResultChunk.encode(v!, writer.uint32(42).fork()).join();
      }
      if (message.error !== undefined) {
        writer.uint32(50).string(message.error);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetDeepResearcherJobResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetDeepResearcherJobResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.jobId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.status = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.createdAt = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.updatedAt = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.result.push(
              DeepResearcherResultChunk.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.error = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetDeepResearcherJobResponse {
      return {
        jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
        status: isSet(object.status) ? globalThis.String(object.status) : "",
        createdAt: isSet(object.createdAt)
          ? globalThis.String(object.createdAt)
          : "",
        updatedAt: isSet(object.updatedAt)
          ? globalThis.String(object.updatedAt)
          : "",
        result: globalThis.Array.isArray(object?.result)
          ? object.result.map((e: any) => DeepResearcherResultChunk.fromJSON(e))
          : [],
        error: isSet(object.error)
          ? globalThis.String(object.error)
          : undefined,
      };
    },

    toJSON(message: GetDeepResearcherJobResponse): unknown {
      const obj: any = {};
      if (message.jobId !== "") {
        obj.jobId = message.jobId;
      }
      if (message.status !== "") {
        obj.status = message.status;
      }
      if (message.createdAt !== "") {
        obj.createdAt = message.createdAt;
      }
      if (message.updatedAt !== "") {
        obj.updatedAt = message.updatedAt;
      }
      if (message.result?.length) {
        obj.result = message.result.map(e =>
          DeepResearcherResultChunk.toJSON(e),
        );
      }
      if (message.error !== undefined) {
        obj.error = message.error;
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetDeepResearcherJobResponse>,
    ): GetDeepResearcherJobResponse {
      return GetDeepResearcherJobResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetDeepResearcherJobResponse>,
    ): GetDeepResearcherJobResponse {
      const message = createBaseGetDeepResearcherJobResponse();
      message.jobId = object.jobId ?? "";
      message.status = object.status ?? "";
      message.createdAt = object.createdAt ?? "";
      message.updatedAt = object.updatedAt ?? "";
      message.result =
        object.result?.map(e => DeepResearcherResultChunk.fromPartial(e)) || [];
      message.error = object.error ?? undefined;
      return message;
    },
  };

function createBaseDeepResearcherResultChunk(): DeepResearcherResultChunk {
  return { seqId: 0, chunk: "" };
}

export const DeepResearcherResultChunk: MessageFns<DeepResearcherResultChunk> =
  {
    encode(
      message: DeepResearcherResultChunk,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.seqId !== 0) {
        writer.uint32(8).int64(message.seqId);
      }
      if (message.chunk !== "") {
        writer.uint32(18).string(message.chunk);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): DeepResearcherResultChunk {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDeepResearcherResultChunk();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.seqId = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.chunk = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DeepResearcherResultChunk {
      return {
        seqId: isSet(object.seqId) ? globalThis.Number(object.seqId) : 0,
        chunk: isSet(object.chunk) ? globalThis.String(object.chunk) : "",
      };
    },

    toJSON(message: DeepResearcherResultChunk): unknown {
      const obj: any = {};
      if (message.seqId !== 0) {
        obj.seqId = Math.round(message.seqId);
      }
      if (message.chunk !== "") {
        obj.chunk = message.chunk;
      }
      return obj;
    },

    create(
      base?: DeepPartial<DeepResearcherResultChunk>,
    ): DeepResearcherResultChunk {
      return DeepResearcherResultChunk.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<DeepResearcherResultChunk>,
    ): DeepResearcherResultChunk {
      const message = createBaseDeepResearcherResultChunk();
      message.seqId = object.seqId ?? 0;
      message.chunk = object.chunk ?? "";
      return message;
    },
  };

function createBaseGetDeepResearcherJobRequest(): GetDeepResearcherJobRequest {
  return { jobId: "" };
}

export const GetDeepResearcherJobRequest: MessageFns<GetDeepResearcherJobRequest> =
  {
    encode(
      message: GetDeepResearcherJobRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.jobId !== "") {
        writer.uint32(10).string(message.jobId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetDeepResearcherJobRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetDeepResearcherJobRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.jobId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetDeepResearcherJobRequest {
      return {
        jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      };
    },

    toJSON(message: GetDeepResearcherJobRequest): unknown {
      const obj: any = {};
      if (message.jobId !== "") {
        obj.jobId = message.jobId;
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetDeepResearcherJobRequest>,
    ): GetDeepResearcherJobRequest {
      return GetDeepResearcherJobRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetDeepResearcherJobRequest>,
    ): GetDeepResearcherJobRequest {
      const message = createBaseGetDeepResearcherJobRequest();
      message.jobId = object.jobId ?? "";
      return message;
    },
  };

function createBaseChatSession(): ChatSession {
  return {
    id: "",
    userId: "",
    title: "",
    chatType: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const ChatSession: MessageFns<ChatSession> = {
  encode(
    message: ChatSession,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.chatType !== "") {
      writer.uint32(34).string(message.chatType);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.createdAt),
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.updatedAt),
        writer.uint32(50).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatSession {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chatType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatSession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      chatType: isSet(object.chatType)
        ? globalThis.String(object.chatType)
        : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : undefined,
      updatedAt: isSet(object.updatedAt)
        ? fromJsonTimestamp(object.updatedAt)
        : undefined,
    };
  },

  toJSON(message: ChatSession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.chatType !== "") {
      obj.chatType = message.chatType;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ChatSession>): ChatSession {
    return ChatSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChatSession>): ChatSession {
    const message = createBaseChatSession();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.title = object.title ?? "";
    message.chatType = object.chatType ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetChatSessionsResponse(): GetChatSessionsResponse {
  return { chatSessions: [] };
}

export const GetChatSessionsResponse: MessageFns<GetChatSessionsResponse> = {
  encode(
    message: GetChatSessionsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.chatSessions) {
      ChatSession.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetChatSessionsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChatSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatSessions.push(
            ChatSession.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChatSessionsResponse {
    return {
      chatSessions: globalThis.Array.isArray(object?.chatSessions)
        ? object.chatSessions.map((e: any) => ChatSession.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetChatSessionsResponse): unknown {
    const obj: any = {};
    if (message.chatSessions?.length) {
      obj.chatSessions = message.chatSessions.map(e => ChatSession.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetChatSessionsResponse>): GetChatSessionsResponse {
    return GetChatSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetChatSessionsResponse>,
  ): GetChatSessionsResponse {
    const message = createBaseGetChatSessionsResponse();
    message.chatSessions =
      object.chatSessions?.map(e => ChatSession.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStoredChatCompletionsRequest(): GetStoredChatCompletionsRequest {
  return { chatId: "" };
}

export const GetStoredChatCompletionsRequest: MessageFns<GetStoredChatCompletionsRequest> =
  {
    encode(
      message: GetStoredChatCompletionsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.chatId !== "") {
        writer.uint32(10).string(message.chatId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetStoredChatCompletionsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetStoredChatCompletionsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.chatId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetStoredChatCompletionsRequest {
      return {
        chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      };
    },

    toJSON(message: GetStoredChatCompletionsRequest): unknown {
      const obj: any = {};
      if (message.chatId !== "") {
        obj.chatId = message.chatId;
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetStoredChatCompletionsRequest>,
    ): GetStoredChatCompletionsRequest {
      return GetStoredChatCompletionsRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetStoredChatCompletionsRequest>,
    ): GetStoredChatCompletionsRequest {
      const message = createBaseGetStoredChatCompletionsRequest();
      message.chatId = object.chatId ?? "";
      return message;
    },
  };

function createBaseStoredChatCompletion(): StoredChatCompletion {
  return {
    id: "",
    chatId: "",
    completionType: "",
    createdAt: undefined,
    completedAt: undefined,
    userPromptText: "",
    completionText: "",
    metadata: undefined,
    errorMessage: "",
  };
}

export const StoredChatCompletion: MessageFns<StoredChatCompletion> = {
  encode(
    message: StoredChatCompletion,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    if (message.completionType !== "") {
      writer.uint32(26).string(message.completionType);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.createdAt),
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(
        toTimestamp(message.completedAt),
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.userPromptText !== "") {
      writer.uint32(50).string(message.userPromptText);
    }
    if (message.completionText !== "") {
      writer.uint32(58).string(message.completionText);
    }
    if (message.metadata !== undefined) {
      Struct.encode(
        Struct.wrap(message.metadata),
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StoredChatCompletion {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoredChatCompletion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.completionType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.completedAt = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userPromptText = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.completionText = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(
            Struct.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoredChatCompletion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      completionType: isSet(object.completionType)
        ? globalThis.String(object.completionType)
        : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : undefined,
      completedAt: isSet(object.completedAt)
        ? fromJsonTimestamp(object.completedAt)
        : undefined,
      userPromptText: isSet(object.userPromptText)
        ? globalThis.String(object.userPromptText)
        : "",
      completionText: isSet(object.completionText)
        ? globalThis.String(object.completionText)
        : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : "",
    };
  },

  toJSON(message: StoredChatCompletion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.completionType !== "") {
      obj.completionType = message.completionType;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.userPromptText !== "") {
      obj.userPromptText = message.userPromptText;
    }
    if (message.completionText !== "") {
      obj.completionText = message.completionText;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<StoredChatCompletion>): StoredChatCompletion {
    return StoredChatCompletion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoredChatCompletion>): StoredChatCompletion {
    const message = createBaseStoredChatCompletion();
    message.id = object.id ?? "";
    message.chatId = object.chatId ?? "";
    message.completionType = object.completionType ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.userPromptText = object.userPromptText ?? "";
    message.completionText = object.completionText ?? "";
    message.metadata = object.metadata ?? undefined;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseGetStoredChatCompletionsResponse(): GetStoredChatCompletionsResponse {
  return { chatCompletions: [] };
}

export const GetStoredChatCompletionsResponse: MessageFns<GetStoredChatCompletionsResponse> =
  {
    encode(
      message: GetStoredChatCompletionsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.chatCompletions) {
        StoredChatCompletion.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetStoredChatCompletionsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetStoredChatCompletionsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.chatCompletions.push(
              StoredChatCompletion.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetStoredChatCompletionsResponse {
      return {
        chatCompletions: globalThis.Array.isArray(object?.chatCompletions)
          ? object.chatCompletions.map((e: any) =>
              StoredChatCompletion.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: GetStoredChatCompletionsResponse): unknown {
      const obj: any = {};
      if (message.chatCompletions?.length) {
        obj.chatCompletions = message.chatCompletions.map(e =>
          StoredChatCompletion.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetStoredChatCompletionsResponse>,
    ): GetStoredChatCompletionsResponse {
      return GetStoredChatCompletionsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetStoredChatCompletionsResponse>,
    ): GetStoredChatCompletionsResponse {
      const message = createBaseGetStoredChatCompletionsResponse();
      message.chatCompletions =
        object.chatCompletions?.map(e => StoredChatCompletion.fromPartial(e)) ||
        [];
      return message;
    },
  };

function createBaseUpdateChatAttributeRequest(): UpdateChatAttributeRequest {
  return { chatId: "", attributes: {} };
}

export const UpdateChatAttributeRequest: MessageFns<UpdateChatAttributeRequest> =
  {
    encode(
      message: UpdateChatAttributeRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.chatId !== "") {
        writer.uint32(10).string(message.chatId);
      }
      Object.entries(message.attributes).forEach(([key, value]) => {
        UpdateChatAttributeRequest_AttributesEntry.encode(
          { key: key as any, value },
          writer.uint32(18).fork(),
        ).join();
      });
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): UpdateChatAttributeRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUpdateChatAttributeRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.chatId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            const entry2 = UpdateChatAttributeRequest_AttributesEntry.decode(
              reader,
              reader.uint32(),
            );
            if (entry2.value !== undefined) {
              message.attributes[entry2.key] = entry2.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UpdateChatAttributeRequest {
      return {
        chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
        attributes: isObject(object.attributes)
          ? Object.entries(object.attributes).reduce<{ [key: string]: string }>(
              (acc, [key, value]) => {
                acc[key] = String(value);
                return acc;
              },
              {},
            )
          : {},
      };
    },

    toJSON(message: UpdateChatAttributeRequest): unknown {
      const obj: any = {};
      if (message.chatId !== "") {
        obj.chatId = message.chatId;
      }
      if (message.attributes) {
        const entries = Object.entries(message.attributes);
        if (entries.length > 0) {
          obj.attributes = {};
          entries.forEach(([k, v]) => {
            obj.attributes[k] = v;
          });
        }
      }
      return obj;
    },

    create(
      base?: DeepPartial<UpdateChatAttributeRequest>,
    ): UpdateChatAttributeRequest {
      return UpdateChatAttributeRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<UpdateChatAttributeRequest>,
    ): UpdateChatAttributeRequest {
      const message = createBaseUpdateChatAttributeRequest();
      message.chatId = object.chatId ?? "";
      message.attributes = Object.entries(object.attributes ?? {}).reduce<{
        [key: string]: string;
      }>((acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      }, {});
      return message;
    },
  };

function createBaseUpdateChatAttributeRequest_AttributesEntry(): UpdateChatAttributeRequest_AttributesEntry {
  return { key: "", value: "" };
}

export const UpdateChatAttributeRequest_AttributesEntry: MessageFns<UpdateChatAttributeRequest_AttributesEntry> =
  {
    encode(
      message: UpdateChatAttributeRequest_AttributesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): UpdateChatAttributeRequest_AttributesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUpdateChatAttributeRequest_AttributesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UpdateChatAttributeRequest_AttributesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: UpdateChatAttributeRequest_AttributesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<UpdateChatAttributeRequest_AttributesEntry>,
    ): UpdateChatAttributeRequest_AttributesEntry {
      return UpdateChatAttributeRequest_AttributesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<UpdateChatAttributeRequest_AttributesEntry>,
    ): UpdateChatAttributeRequest_AttributesEntry {
      const message = createBaseUpdateChatAttributeRequest_AttributesEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseUpdateChatAttributeResponse(): UpdateChatAttributeResponse {
  return { success: false };
}

export const UpdateChatAttributeResponse: MessageFns<UpdateChatAttributeResponse> =
  {
    encode(
      message: UpdateChatAttributeResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.success !== false) {
        writer.uint32(8).bool(message.success);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): UpdateChatAttributeResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUpdateChatAttributeResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.success = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UpdateChatAttributeResponse {
      return {
        success: isSet(object.success)
          ? globalThis.Boolean(object.success)
          : false,
      };
    },

    toJSON(message: UpdateChatAttributeResponse): unknown {
      const obj: any = {};
      if (message.success !== false) {
        obj.success = message.success;
      }
      return obj;
    },

    create(
      base?: DeepPartial<UpdateChatAttributeResponse>,
    ): UpdateChatAttributeResponse {
      return UpdateChatAttributeResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<UpdateChatAttributeResponse>,
    ): UpdateChatAttributeResponse {
      const message = createBaseUpdateChatAttributeResponse();
      message.success = object.success ?? false;
      return message;
    },
  };

function createBaseDeleteChatsRequest(): DeleteChatsRequest {
  return { chatIds: [] };
}

export const DeleteChatsRequest: MessageFns<DeleteChatsRequest> = {
  encode(
    message: DeleteChatsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.chatIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteChatsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChatsRequest {
    return {
      chatIds: globalThis.Array.isArray(object?.chatIds)
        ? object.chatIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteChatsRequest): unknown {
    const obj: any = {};
    if (message.chatIds?.length) {
      obj.chatIds = message.chatIds;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteChatsRequest>): DeleteChatsRequest {
    return DeleteChatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteChatsRequest>): DeleteChatsRequest {
    const message = createBaseDeleteChatsRequest();
    message.chatIds = object.chatIds?.map(e => e) || [];
    return message;
  },
};

function createBaseDeleteChatsResponse(): DeleteChatsResponse {
  return { success: false };
}

export const DeleteChatsResponse: MessageFns<DeleteChatsResponse> = {
  encode(
    message: DeleteChatsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteChatsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChatsResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
    };
  },

  toJSON(message: DeleteChatsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteChatsResponse>): DeleteChatsResponse {
    return DeleteChatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteChatsResponse>): DeleteChatsResponse {
    const message = createBaseDeleteChatsResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export type ApexServiceService = typeof ApexServiceService;
export const ApexServiceService = {
  /** ChatCompletion generates a completion for a given request. */
  chatCompletion: {
    path: "/apex.v1.ApexService/ChatCompletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChatCompletionRequest) =>
      Buffer.from(ChatCompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatCompletionRequest.decode(value),
    responseSerialize: (value: ChatCompletionResponse) =>
      Buffer.from(ChatCompletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ChatCompletionResponse.decode(value),
  },
  /** ChatCompletionStream generates a stream of completions for a given request. */
  chatCompletionStream: {
    path: "/apex.v1.ApexService/ChatCompletionStream",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ChatCompletionRequest) =>
      Buffer.from(ChatCompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatCompletionRequest.decode(value),
    responseSerialize: (value: ChatCompletionChunkResponse) =>
      Buffer.from(ChatCompletionChunkResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ChatCompletionChunkResponse.decode(value),
  },
  /** WebRetrieval retrieves web search results for a given request. */
  webRetrieval: {
    path: "/apex.v1.ApexService/WebRetrieval",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WebRetrievalRequest) =>
      Buffer.from(WebRetrievalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WebRetrievalRequest.decode(value),
    responseSerialize: (value: WebRetrievalResponse) =>
      Buffer.from(WebRetrievalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WebRetrievalResponse.decode(value),
  },
  /** SubmitDeepResearcherJob submits a new deep researcher job for processing. */
  submitDeepResearcherJob: {
    path: "/apex.v1.ApexService/SubmitDeepResearcherJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChatCompletionRequest) =>
      Buffer.from(ChatCompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatCompletionRequest.decode(value),
    responseSerialize: (value: SubmitDeepResearcherJobResponse) =>
      Buffer.from(SubmitDeepResearcherJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      SubmitDeepResearcherJobResponse.decode(value),
  },
  /** GetDeepResearcherJob retrieves the status and results of a deep researcher job. */
  getDeepResearcherJob: {
    path: "/apex.v1.ApexService/GetDeepResearcherJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDeepResearcherJobRequest) =>
      Buffer.from(GetDeepResearcherJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetDeepResearcherJobRequest.decode(value),
    responseSerialize: (value: GetDeepResearcherJobResponse) =>
      Buffer.from(GetDeepResearcherJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetDeepResearcherJobResponse.decode(value),
  },
  /** GetChatSessions retrieves a user's chats */
  getChatSessions: {
    path: "/apex.v1.ApexService/GetChatSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) =>
      Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetChatSessionsResponse) =>
      Buffer.from(GetChatSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetChatSessionsResponse.decode(value),
  },
  /** GetStoredChatCompletions retrieves a chat's completions */
  getStoredChatCompletions: {
    path: "/apex.v1.ApexService/GetStoredChatCompletions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStoredChatCompletionsRequest) =>
      Buffer.from(GetStoredChatCompletionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetStoredChatCompletionsRequest.decode(value),
    responseSerialize: (value: GetStoredChatCompletionsResponse) =>
      Buffer.from(GetStoredChatCompletionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetStoredChatCompletionsResponse.decode(value),
  },
  /** UpdateChatAttribute updates attribute after asking LLM for one */
  updateChatAttribute: {
    path: "/apex.v1.ApexService/UpdateChatAttribute",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateChatAttributeRequest) =>
      Buffer.from(UpdateChatAttributeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      UpdateChatAttributeRequest.decode(value),
    responseSerialize: (value: UpdateChatAttributeResponse) =>
      Buffer.from(UpdateChatAttributeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      UpdateChatAttributeResponse.decode(value),
  },
  /** DeleteChats removes chats based on the specified chat_ids */
  deleteChats: {
    path: "/apex.v1.ApexService/DeleteChats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteChatsRequest) =>
      Buffer.from(DeleteChatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteChatsRequest.decode(value),
    responseSerialize: (value: DeleteChatsResponse) =>
      Buffer.from(DeleteChatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteChatsResponse.decode(value),
  },
} as const;

export interface ApexServiceServer extends UntypedServiceImplementation {
  /** ChatCompletion generates a completion for a given request. */
  chatCompletion: handleUnaryCall<
    ChatCompletionRequest,
    ChatCompletionResponse
  >;
  /** ChatCompletionStream generates a stream of completions for a given request. */
  chatCompletionStream: handleServerStreamingCall<
    ChatCompletionRequest,
    ChatCompletionChunkResponse
  >;
  /** WebRetrieval retrieves web search results for a given request. */
  webRetrieval: handleUnaryCall<WebRetrievalRequest, WebRetrievalResponse>;
  /** SubmitDeepResearcherJob submits a new deep researcher job for processing. */
  submitDeepResearcherJob: handleUnaryCall<
    ChatCompletionRequest,
    SubmitDeepResearcherJobResponse
  >;
  /** GetDeepResearcherJob retrieves the status and results of a deep researcher job. */
  getDeepResearcherJob: handleUnaryCall<
    GetDeepResearcherJobRequest,
    GetDeepResearcherJobResponse
  >;
  /** GetChatSessions retrieves a user's chats */
  getChatSessions: handleUnaryCall<Empty, GetChatSessionsResponse>;
  /** GetStoredChatCompletions retrieves a chat's completions */
  getStoredChatCompletions: handleUnaryCall<
    GetStoredChatCompletionsRequest,
    GetStoredChatCompletionsResponse
  >;
  /** UpdateChatAttribute updates attribute after asking LLM for one */
  updateChatAttribute: handleUnaryCall<
    UpdateChatAttributeRequest,
    UpdateChatAttributeResponse
  >;
  /** DeleteChats removes chats based on the specified chat_ids */
  deleteChats: handleUnaryCall<DeleteChatsRequest, DeleteChatsResponse>;
}

export interface ApexServiceClient extends Client {
  /** ChatCompletion generates a completion for a given request. */
  chatCompletion(
    request: ChatCompletionRequest,
    callback: (
      error: ServiceError | null,
      response: ChatCompletionResponse,
    ) => void,
  ): ClientUnaryCall;
  chatCompletion(
    request: ChatCompletionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ChatCompletionResponse,
    ) => void,
  ): ClientUnaryCall;
  chatCompletion(
    request: ChatCompletionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ChatCompletionResponse,
    ) => void,
  ): ClientUnaryCall;
  /** ChatCompletionStream generates a stream of completions for a given request. */
  chatCompletionStream(
    request: ChatCompletionRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ChatCompletionChunkResponse>;
  chatCompletionStream(
    request: ChatCompletionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ChatCompletionChunkResponse>;
  /** WebRetrieval retrieves web search results for a given request. */
  webRetrieval(
    request: WebRetrievalRequest,
    callback: (
      error: ServiceError | null,
      response: WebRetrievalResponse,
    ) => void,
  ): ClientUnaryCall;
  webRetrieval(
    request: WebRetrievalRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: WebRetrievalResponse,
    ) => void,
  ): ClientUnaryCall;
  webRetrieval(
    request: WebRetrievalRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: WebRetrievalResponse,
    ) => void,
  ): ClientUnaryCall;
  /** SubmitDeepResearcherJob submits a new deep researcher job for processing. */
  submitDeepResearcherJob(
    request: ChatCompletionRequest,
    callback: (
      error: ServiceError | null,
      response: SubmitDeepResearcherJobResponse,
    ) => void,
  ): ClientUnaryCall;
  submitDeepResearcherJob(
    request: ChatCompletionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: SubmitDeepResearcherJobResponse,
    ) => void,
  ): ClientUnaryCall;
  submitDeepResearcherJob(
    request: ChatCompletionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: SubmitDeepResearcherJobResponse,
    ) => void,
  ): ClientUnaryCall;
  /** GetDeepResearcherJob retrieves the status and results of a deep researcher job. */
  getDeepResearcherJob(
    request: GetDeepResearcherJobRequest,
    callback: (
      error: ServiceError | null,
      response: GetDeepResearcherJobResponse,
    ) => void,
  ): ClientUnaryCall;
  getDeepResearcherJob(
    request: GetDeepResearcherJobRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetDeepResearcherJobResponse,
    ) => void,
  ): ClientUnaryCall;
  getDeepResearcherJob(
    request: GetDeepResearcherJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetDeepResearcherJobResponse,
    ) => void,
  ): ClientUnaryCall;
  /** GetChatSessions retrieves a user's chats */
  getChatSessions(
    request: Empty,
    callback: (
      error: ServiceError | null,
      response: GetChatSessionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getChatSessions(
    request: Empty,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetChatSessionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getChatSessions(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetChatSessionsResponse,
    ) => void,
  ): ClientUnaryCall;
  /** GetStoredChatCompletions retrieves a chat's completions */
  getStoredChatCompletions(
    request: GetStoredChatCompletionsRequest,
    callback: (
      error: ServiceError | null,
      response: GetStoredChatCompletionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getStoredChatCompletions(
    request: GetStoredChatCompletionsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetStoredChatCompletionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getStoredChatCompletions(
    request: GetStoredChatCompletionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetStoredChatCompletionsResponse,
    ) => void,
  ): ClientUnaryCall;
  /** UpdateChatAttribute updates attribute after asking LLM for one */
  updateChatAttribute(
    request: UpdateChatAttributeRequest,
    callback: (
      error: ServiceError | null,
      response: UpdateChatAttributeResponse,
    ) => void,
  ): ClientUnaryCall;
  updateChatAttribute(
    request: UpdateChatAttributeRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: UpdateChatAttributeResponse,
    ) => void,
  ): ClientUnaryCall;
  updateChatAttribute(
    request: UpdateChatAttributeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: UpdateChatAttributeResponse,
    ) => void,
  ): ClientUnaryCall;
  /** DeleteChats removes chats based on the specified chat_ids */
  deleteChats(
    request: DeleteChatsRequest,
    callback: (
      error: ServiceError | null,
      response: DeleteChatsResponse,
    ) => void,
  ): ClientUnaryCall;
  deleteChats(
    request: DeleteChatsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: DeleteChatsResponse,
    ) => void,
  ): ClientUnaryCall;
  deleteChats(
    request: DeleteChatsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: DeleteChatsResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const ApexServiceClient = makeGenericClientConstructor(
  ApexServiceService,
  "apex.v1.ApexService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): ApexServiceClient;
  service: typeof ApexServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
