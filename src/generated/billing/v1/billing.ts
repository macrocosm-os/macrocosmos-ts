// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: billing/v1/billing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "billing.v1";

/** GetUsageRequest is the request message for getting the usage of the user's credits */
export interface GetUsageRequest {
  /** product_type: the type of the product (i.e. "gravity") */
  productType?: string | undefined;
}

/** BillingRate is the billing rate for a product */
export interface BillingRate {
  /** rate_type: the type of the billing rate (i.e. "gravity") */
  rateType: string;
  /** unit_size: the size of the unit of the subscription (e.g. 1000, 10000, 100000) */
  unitSize: number;
  /** unit_type: the type of the unit of the subscription (i.e. "rows") */
  unitType: string;
  /** price_per_unit: the price per unit of the subscription */
  pricePerUnit: number;
  /** currency: the currency of the subscription */
  currency: string;
}

/** SubscriptionInfo contains the active subscription details */
export interface SubscriptionInfo {
  /** external_id: the external ID of the subscription */
  externalId: string;
  /** plan_code: the plan code of the subscription */
  planCode: string;
  /** plan_tier: the tier of the plan (0=Free, 1=Astronaut, 2=Cosmonaut) */
  planTier: number;
  /** free_allowance_usd: the total free allowance in USD per month for the active subscription */
  freeAllowanceUsd: number;
  /** free_allowance_remaining_usd: the remaining free allowance in USD for the current period */
  freeAllowanceRemainingUsd: number;
  /** usage_in_usd: the current usage amount in USD for the billing period */
  usageInUsd: number;
}

/** GetUsageResponse is the response message for getting the usage of the user's credits */
export interface GetUsageResponse {
  /** available_credits: the number of credits available to the user */
  availableCredits: number;
  /** used_credits: the number of credits used by the user */
  usedCredits: number;
  /** remaining_credits: the number of credits remaining to the user */
  remainingCredits: number;
  /** subscription: the subscription that the user has */
  billingRates: BillingRate[];
  /** active_subscription: the currently active subscription */
  activeSubscription?: SubscriptionInfo | undefined;
}

/** ChargeUserForUsageRequest is the request message for charging a user for usage */
export interface ChargeUserForUsageRequest {
  /** transaction_id: unique identifier for this transaction */
  transactionId: string;
  /** channel: the gravity service channel ("dataset" or "on_demand") */
  channel: string;
  /** rows: the number of rows to charge for (can be negative for refunds) */
  rows: number;
}

/** ChargeUserForUsageResponse is the response message for charging a user for usage */
export interface ChargeUserForUsageResponse {
  /** charge_cents: the amount charged in cents */
  chargeCents: number;
  /** transaction_id: the transaction ID */
  transactionId: string;
  /** channel: the channel that was charged */
  channel: string;
  /** rows: the number of rows charged */
  rows: number;
}

/** UserHasEnoughAllowanceAndCreditsRequest is the request message for checking if a user has enough allowance and credits */
export interface UserHasEnoughAllowanceAndCreditsRequest {
  /** channel: the gravity service channel ("dataset" or "on_demand") */
  channel: string;
  /** rows: the number of rows to check for */
  rows: number;
}

/** UserHasEnoughAllowanceAndCreditsResponse is the response message for checking if a user has enough allowance and credits */
export interface UserHasEnoughAllowanceAndCreditsResponse {
  /** has_enough: whether the user has enough allowance and credits */
  hasEnough: boolean;
  /** charge_cents: the amount that would be charged in cents */
  chargeCents: number;
  /** channel: the channel that would be charged */
  channel: string;
  /** rows: the number of rows that would be charged */
  rows: number;
}

function createBaseGetUsageRequest(): GetUsageRequest {
  return { productType: undefined };
}

export const GetUsageRequest: MessageFns<GetUsageRequest> = {
  encode(
    message: GetUsageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.productType !== undefined) {
      writer.uint32(10).string(message.productType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageRequest {
    return {
      productType: isSet(object.productType)
        ? globalThis.String(object.productType)
        : undefined,
    };
  },

  toJSON(message: GetUsageRequest): unknown {
    const obj: any = {};
    if (message.productType !== undefined) {
      obj.productType = message.productType;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUsageRequest>): GetUsageRequest {
    return GetUsageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUsageRequest>): GetUsageRequest {
    const message = createBaseGetUsageRequest();
    message.productType = object.productType ?? undefined;
    return message;
  },
};

function createBaseBillingRate(): BillingRate {
  return {
    rateType: "",
    unitSize: 0,
    unitType: "",
    pricePerUnit: 0,
    currency: "",
  };
}

export const BillingRate: MessageFns<BillingRate> = {
  encode(
    message: BillingRate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rateType !== "") {
      writer.uint32(10).string(message.rateType);
    }
    if (message.unitSize !== 0) {
      writer.uint32(16).int64(message.unitSize);
    }
    if (message.unitType !== "") {
      writer.uint32(26).string(message.unitType);
    }
    if (message.pricePerUnit !== 0) {
      writer.uint32(37).float(message.pricePerUnit);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BillingRate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillingRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rateType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unitSize = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unitType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.pricePerUnit = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BillingRate {
    return {
      rateType: isSet(object.rateType)
        ? globalThis.String(object.rateType)
        : "",
      unitSize: isSet(object.unitSize) ? globalThis.Number(object.unitSize) : 0,
      unitType: isSet(object.unitType)
        ? globalThis.String(object.unitType)
        : "",
      pricePerUnit: isSet(object.pricePerUnit)
        ? globalThis.Number(object.pricePerUnit)
        : 0,
      currency: isSet(object.currency)
        ? globalThis.String(object.currency)
        : "",
    };
  },

  toJSON(message: BillingRate): unknown {
    const obj: any = {};
    if (message.rateType !== "") {
      obj.rateType = message.rateType;
    }
    if (message.unitSize !== 0) {
      obj.unitSize = Math.round(message.unitSize);
    }
    if (message.unitType !== "") {
      obj.unitType = message.unitType;
    }
    if (message.pricePerUnit !== 0) {
      obj.pricePerUnit = message.pricePerUnit;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create(base?: DeepPartial<BillingRate>): BillingRate {
    return BillingRate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BillingRate>): BillingRate {
    const message = createBaseBillingRate();
    message.rateType = object.rateType ?? "";
    message.unitSize = object.unitSize ?? 0;
    message.unitType = object.unitType ?? "";
    message.pricePerUnit = object.pricePerUnit ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseSubscriptionInfo(): SubscriptionInfo {
  return {
    externalId: "",
    planCode: "",
    planTier: 0,
    freeAllowanceUsd: 0,
    freeAllowanceRemainingUsd: 0,
    usageInUsd: 0,
  };
}

export const SubscriptionInfo: MessageFns<SubscriptionInfo> = {
  encode(
    message: SubscriptionInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.externalId !== "") {
      writer.uint32(10).string(message.externalId);
    }
    if (message.planCode !== "") {
      writer.uint32(18).string(message.planCode);
    }
    if (message.planTier !== 0) {
      writer.uint32(24).int32(message.planTier);
    }
    if (message.freeAllowanceUsd !== 0) {
      writer.uint32(37).float(message.freeAllowanceUsd);
    }
    if (message.freeAllowanceRemainingUsd !== 0) {
      writer.uint32(45).float(message.freeAllowanceRemainingUsd);
    }
    if (message.usageInUsd !== 0) {
      writer.uint32(53).float(message.usageInUsd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.planCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.planTier = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.freeAllowanceUsd = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.freeAllowanceRemainingUsd = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.usageInUsd = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionInfo {
    return {
      externalId: isSet(object.externalId)
        ? globalThis.String(object.externalId)
        : "",
      planCode: isSet(object.planCode)
        ? globalThis.String(object.planCode)
        : "",
      planTier: isSet(object.planTier) ? globalThis.Number(object.planTier) : 0,
      freeAllowanceUsd: isSet(object.freeAllowanceUsd)
        ? globalThis.Number(object.freeAllowanceUsd)
        : 0,
      freeAllowanceRemainingUsd: isSet(object.freeAllowanceRemainingUsd)
        ? globalThis.Number(object.freeAllowanceRemainingUsd)
        : 0,
      usageInUsd: isSet(object.usageInUsd)
        ? globalThis.Number(object.usageInUsd)
        : 0,
    };
  },

  toJSON(message: SubscriptionInfo): unknown {
    const obj: any = {};
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.planCode !== "") {
      obj.planCode = message.planCode;
    }
    if (message.planTier !== 0) {
      obj.planTier = Math.round(message.planTier);
    }
    if (message.freeAllowanceUsd !== 0) {
      obj.freeAllowanceUsd = message.freeAllowanceUsd;
    }
    if (message.freeAllowanceRemainingUsd !== 0) {
      obj.freeAllowanceRemainingUsd = message.freeAllowanceRemainingUsd;
    }
    if (message.usageInUsd !== 0) {
      obj.usageInUsd = message.usageInUsd;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptionInfo>): SubscriptionInfo {
    return SubscriptionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionInfo>): SubscriptionInfo {
    const message = createBaseSubscriptionInfo();
    message.externalId = object.externalId ?? "";
    message.planCode = object.planCode ?? "";
    message.planTier = object.planTier ?? 0;
    message.freeAllowanceUsd = object.freeAllowanceUsd ?? 0;
    message.freeAllowanceRemainingUsd = object.freeAllowanceRemainingUsd ?? 0;
    message.usageInUsd = object.usageInUsd ?? 0;
    return message;
  },
};

function createBaseGetUsageResponse(): GetUsageResponse {
  return {
    availableCredits: 0,
    usedCredits: 0,
    remainingCredits: 0,
    billingRates: [],
    activeSubscription: undefined,
  };
}

export const GetUsageResponse: MessageFns<GetUsageResponse> = {
  encode(
    message: GetUsageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.availableCredits !== 0) {
      writer.uint32(13).float(message.availableCredits);
    }
    if (message.usedCredits !== 0) {
      writer.uint32(21).float(message.usedCredits);
    }
    if (message.remainingCredits !== 0) {
      writer.uint32(29).float(message.remainingCredits);
    }
    for (const v of message.billingRates) {
      BillingRate.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.activeSubscription !== undefined) {
      SubscriptionInfo.encode(
        message.activeSubscription,
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.availableCredits = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.usedCredits = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.remainingCredits = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.billingRates.push(
            BillingRate.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.activeSubscription = SubscriptionInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsageResponse {
    return {
      availableCredits: isSet(object.availableCredits)
        ? globalThis.Number(object.availableCredits)
        : 0,
      usedCredits: isSet(object.usedCredits)
        ? globalThis.Number(object.usedCredits)
        : 0,
      remainingCredits: isSet(object.remainingCredits)
        ? globalThis.Number(object.remainingCredits)
        : 0,
      billingRates: globalThis.Array.isArray(object?.billingRates)
        ? object.billingRates.map((e: any) => BillingRate.fromJSON(e))
        : [],
      activeSubscription: isSet(object.activeSubscription)
        ? SubscriptionInfo.fromJSON(object.activeSubscription)
        : undefined,
    };
  },

  toJSON(message: GetUsageResponse): unknown {
    const obj: any = {};
    if (message.availableCredits !== 0) {
      obj.availableCredits = message.availableCredits;
    }
    if (message.usedCredits !== 0) {
      obj.usedCredits = message.usedCredits;
    }
    if (message.remainingCredits !== 0) {
      obj.remainingCredits = message.remainingCredits;
    }
    if (message.billingRates?.length) {
      obj.billingRates = message.billingRates.map(e => BillingRate.toJSON(e));
    }
    if (message.activeSubscription !== undefined) {
      obj.activeSubscription = SubscriptionInfo.toJSON(
        message.activeSubscription,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<GetUsageResponse>): GetUsageResponse {
    return GetUsageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUsageResponse>): GetUsageResponse {
    const message = createBaseGetUsageResponse();
    message.availableCredits = object.availableCredits ?? 0;
    message.usedCredits = object.usedCredits ?? 0;
    message.remainingCredits = object.remainingCredits ?? 0;
    message.billingRates =
      object.billingRates?.map(e => BillingRate.fromPartial(e)) || [];
    message.activeSubscription =
      object.activeSubscription !== undefined &&
      object.activeSubscription !== null
        ? SubscriptionInfo.fromPartial(object.activeSubscription)
        : undefined;
    return message;
  },
};

function createBaseChargeUserForUsageRequest(): ChargeUserForUsageRequest {
  return { transactionId: "", channel: "", rows: 0 };
}

export const ChargeUserForUsageRequest: MessageFns<ChargeUserForUsageRequest> =
  {
    encode(
      message: ChargeUserForUsageRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transactionId !== "") {
        writer.uint32(10).string(message.transactionId);
      }
      if (message.channel !== "") {
        writer.uint32(18).string(message.channel);
      }
      if (message.rows !== 0) {
        writer.uint32(24).int64(message.rows);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChargeUserForUsageRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChargeUserForUsageRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transactionId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.channel = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.rows = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChargeUserForUsageRequest {
      return {
        transactionId: isSet(object.transactionId)
          ? globalThis.String(object.transactionId)
          : "",
        channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
        rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
      };
    },

    toJSON(message: ChargeUserForUsageRequest): unknown {
      const obj: any = {};
      if (message.transactionId !== "") {
        obj.transactionId = message.transactionId;
      }
      if (message.channel !== "") {
        obj.channel = message.channel;
      }
      if (message.rows !== 0) {
        obj.rows = Math.round(message.rows);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChargeUserForUsageRequest>,
    ): ChargeUserForUsageRequest {
      return ChargeUserForUsageRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChargeUserForUsageRequest>,
    ): ChargeUserForUsageRequest {
      const message = createBaseChargeUserForUsageRequest();
      message.transactionId = object.transactionId ?? "";
      message.channel = object.channel ?? "";
      message.rows = object.rows ?? 0;
      return message;
    },
  };

function createBaseChargeUserForUsageResponse(): ChargeUserForUsageResponse {
  return { chargeCents: 0, transactionId: "", channel: "", rows: 0 };
}

export const ChargeUserForUsageResponse: MessageFns<ChargeUserForUsageResponse> =
  {
    encode(
      message: ChargeUserForUsageResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.chargeCents !== 0) {
        writer.uint32(13).float(message.chargeCents);
      }
      if (message.transactionId !== "") {
        writer.uint32(18).string(message.transactionId);
      }
      if (message.channel !== "") {
        writer.uint32(26).string(message.channel);
      }
      if (message.rows !== 0) {
        writer.uint32(32).int64(message.rows);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ChargeUserForUsageResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseChargeUserForUsageResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 13) {
              break;
            }

            message.chargeCents = reader.float();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.transactionId = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.channel = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.rows = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ChargeUserForUsageResponse {
      return {
        chargeCents: isSet(object.chargeCents)
          ? globalThis.Number(object.chargeCents)
          : 0,
        transactionId: isSet(object.transactionId)
          ? globalThis.String(object.transactionId)
          : "",
        channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
        rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
      };
    },

    toJSON(message: ChargeUserForUsageResponse): unknown {
      const obj: any = {};
      if (message.chargeCents !== 0) {
        obj.chargeCents = message.chargeCents;
      }
      if (message.transactionId !== "") {
        obj.transactionId = message.transactionId;
      }
      if (message.channel !== "") {
        obj.channel = message.channel;
      }
      if (message.rows !== 0) {
        obj.rows = Math.round(message.rows);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ChargeUserForUsageResponse>,
    ): ChargeUserForUsageResponse {
      return ChargeUserForUsageResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ChargeUserForUsageResponse>,
    ): ChargeUserForUsageResponse {
      const message = createBaseChargeUserForUsageResponse();
      message.chargeCents = object.chargeCents ?? 0;
      message.transactionId = object.transactionId ?? "";
      message.channel = object.channel ?? "";
      message.rows = object.rows ?? 0;
      return message;
    },
  };

function createBaseUserHasEnoughAllowanceAndCreditsRequest(): UserHasEnoughAllowanceAndCreditsRequest {
  return { channel: "", rows: 0 };
}

export const UserHasEnoughAllowanceAndCreditsRequest: MessageFns<UserHasEnoughAllowanceAndCreditsRequest> =
  {
    encode(
      message: UserHasEnoughAllowanceAndCreditsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.channel !== "") {
        writer.uint32(10).string(message.channel);
      }
      if (message.rows !== 0) {
        writer.uint32(16).int64(message.rows);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): UserHasEnoughAllowanceAndCreditsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUserHasEnoughAllowanceAndCreditsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.channel = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.rows = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UserHasEnoughAllowanceAndCreditsRequest {
      return {
        channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
        rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
      };
    },

    toJSON(message: UserHasEnoughAllowanceAndCreditsRequest): unknown {
      const obj: any = {};
      if (message.channel !== "") {
        obj.channel = message.channel;
      }
      if (message.rows !== 0) {
        obj.rows = Math.round(message.rows);
      }
      return obj;
    },

    create(
      base?: DeepPartial<UserHasEnoughAllowanceAndCreditsRequest>,
    ): UserHasEnoughAllowanceAndCreditsRequest {
      return UserHasEnoughAllowanceAndCreditsRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<UserHasEnoughAllowanceAndCreditsRequest>,
    ): UserHasEnoughAllowanceAndCreditsRequest {
      const message = createBaseUserHasEnoughAllowanceAndCreditsRequest();
      message.channel = object.channel ?? "";
      message.rows = object.rows ?? 0;
      return message;
    },
  };

function createBaseUserHasEnoughAllowanceAndCreditsResponse(): UserHasEnoughAllowanceAndCreditsResponse {
  return { hasEnough: false, chargeCents: 0, channel: "", rows: 0 };
}

export const UserHasEnoughAllowanceAndCreditsResponse: MessageFns<UserHasEnoughAllowanceAndCreditsResponse> =
  {
    encode(
      message: UserHasEnoughAllowanceAndCreditsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.hasEnough !== false) {
        writer.uint32(8).bool(message.hasEnough);
      }
      if (message.chargeCents !== 0) {
        writer.uint32(21).float(message.chargeCents);
      }
      if (message.channel !== "") {
        writer.uint32(26).string(message.channel);
      }
      if (message.rows !== 0) {
        writer.uint32(32).int64(message.rows);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): UserHasEnoughAllowanceAndCreditsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUserHasEnoughAllowanceAndCreditsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.hasEnough = reader.bool();
            continue;
          }
          case 2: {
            if (tag !== 21) {
              break;
            }

            message.chargeCents = reader.float();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.channel = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.rows = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UserHasEnoughAllowanceAndCreditsResponse {
      return {
        hasEnough: isSet(object.hasEnough)
          ? globalThis.Boolean(object.hasEnough)
          : false,
        chargeCents: isSet(object.chargeCents)
          ? globalThis.Number(object.chargeCents)
          : 0,
        channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
        rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
      };
    },

    toJSON(message: UserHasEnoughAllowanceAndCreditsResponse): unknown {
      const obj: any = {};
      if (message.hasEnough !== false) {
        obj.hasEnough = message.hasEnough;
      }
      if (message.chargeCents !== 0) {
        obj.chargeCents = message.chargeCents;
      }
      if (message.channel !== "") {
        obj.channel = message.channel;
      }
      if (message.rows !== 0) {
        obj.rows = Math.round(message.rows);
      }
      return obj;
    },

    create(
      base?: DeepPartial<UserHasEnoughAllowanceAndCreditsResponse>,
    ): UserHasEnoughAllowanceAndCreditsResponse {
      return UserHasEnoughAllowanceAndCreditsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<UserHasEnoughAllowanceAndCreditsResponse>,
    ): UserHasEnoughAllowanceAndCreditsResponse {
      const message = createBaseUserHasEnoughAllowanceAndCreditsResponse();
      message.hasEnough = object.hasEnough ?? false;
      message.chargeCents = object.chargeCents ?? 0;
      message.channel = object.channel ?? "";
      message.rows = object.rows ?? 0;
      return message;
    },
  };

export type BillingServiceService = typeof BillingServiceService;
export const BillingServiceService = {
  /** Get the usage of the user's credits with subscription-aware billing */
  getUsage: {
    path: "/billing.v1.BillingService/GetUsage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUsageRequest) =>
      Buffer.from(GetUsageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUsageRequest.decode(value),
    responseSerialize: (value: GetUsageResponse) =>
      Buffer.from(GetUsageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUsageResponse.decode(value),
  },
  /** ChargeUserForUsage charges a user for gravity data usage (testing endpoint) */
  chargeUserForUsage: {
    path: "/billing.v1.BillingService/ChargeUserForUsage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChargeUserForUsageRequest) =>
      Buffer.from(ChargeUserForUsageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      ChargeUserForUsageRequest.decode(value),
    responseSerialize: (value: ChargeUserForUsageResponse) =>
      Buffer.from(ChargeUserForUsageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      ChargeUserForUsageResponse.decode(value),
  },
  /** Check if a user has enough allowance and credits to cover a charge (testing endpoint) */
  userHasEnoughAllowanceAndCredits: {
    path: "/billing.v1.BillingService/UserHasEnoughAllowanceAndCredits",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserHasEnoughAllowanceAndCreditsRequest) =>
      Buffer.from(
        UserHasEnoughAllowanceAndCreditsRequest.encode(value).finish(),
      ),
    requestDeserialize: (value: Buffer) =>
      UserHasEnoughAllowanceAndCreditsRequest.decode(value),
    responseSerialize: (value: UserHasEnoughAllowanceAndCreditsResponse) =>
      Buffer.from(
        UserHasEnoughAllowanceAndCreditsResponse.encode(value).finish(),
      ),
    responseDeserialize: (value: Buffer) =>
      UserHasEnoughAllowanceAndCreditsResponse.decode(value),
  },
} as const;

export interface BillingServiceServer extends UntypedServiceImplementation {
  /** Get the usage of the user's credits with subscription-aware billing */
  getUsage: handleUnaryCall<GetUsageRequest, GetUsageResponse>;
  /** ChargeUserForUsage charges a user for gravity data usage (testing endpoint) */
  chargeUserForUsage: handleUnaryCall<
    ChargeUserForUsageRequest,
    ChargeUserForUsageResponse
  >;
  /** Check if a user has enough allowance and credits to cover a charge (testing endpoint) */
  userHasEnoughAllowanceAndCredits: handleUnaryCall<
    UserHasEnoughAllowanceAndCreditsRequest,
    UserHasEnoughAllowanceAndCreditsResponse
  >;
}

export interface BillingServiceClient extends Client {
  /** Get the usage of the user's credits with subscription-aware billing */
  getUsage(
    request: GetUsageRequest,
    callback: (error: ServiceError | null, response: GetUsageResponse) => void,
  ): ClientUnaryCall;
  getUsage(
    request: GetUsageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUsageResponse) => void,
  ): ClientUnaryCall;
  getUsage(
    request: GetUsageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUsageResponse) => void,
  ): ClientUnaryCall;
  /** ChargeUserForUsage charges a user for gravity data usage (testing endpoint) */
  chargeUserForUsage(
    request: ChargeUserForUsageRequest,
    callback: (
      error: ServiceError | null,
      response: ChargeUserForUsageResponse,
    ) => void,
  ): ClientUnaryCall;
  chargeUserForUsage(
    request: ChargeUserForUsageRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: ChargeUserForUsageResponse,
    ) => void,
  ): ClientUnaryCall;
  chargeUserForUsage(
    request: ChargeUserForUsageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: ChargeUserForUsageResponse,
    ) => void,
  ): ClientUnaryCall;
  /** Check if a user has enough allowance and credits to cover a charge (testing endpoint) */
  userHasEnoughAllowanceAndCredits(
    request: UserHasEnoughAllowanceAndCreditsRequest,
    callback: (
      error: ServiceError | null,
      response: UserHasEnoughAllowanceAndCreditsResponse,
    ) => void,
  ): ClientUnaryCall;
  userHasEnoughAllowanceAndCredits(
    request: UserHasEnoughAllowanceAndCreditsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: UserHasEnoughAllowanceAndCreditsResponse,
    ) => void,
  ): ClientUnaryCall;
  userHasEnoughAllowanceAndCredits(
    request: UserHasEnoughAllowanceAndCreditsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: UserHasEnoughAllowanceAndCreditsResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const BillingServiceClient = makeGenericClientConstructor(
  BillingServiceService,
  "billing.v1.BillingService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): BillingServiceClient;
  service: typeof BillingServiceService;
  serviceName: string;
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
